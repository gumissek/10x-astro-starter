Directory structure:
└── src/
    ├── env.d.ts
    ├── types.ts
    ├── components/
    │   ├── UsersList.tsx
    │   ├── Welcome.astro
    │   ├── auth/
    │   │   ├── ForgotPasswordForm.tsx
    │   │   ├── index.ts
    │   │   ├── LoginForm.tsx
    │   │   ├── RegisterForm.tsx
    │   │   └── ResetPasswordForm.tsx
    │   ├── forms/
    │   │   └── ManualFlashcardForm.tsx
    │   ├── hooks/
    │   │   └── useDashboardState.ts
    │   ├── ui/
    │   │   ├── avatar.tsx
    │   │   ├── button.tsx
    │   │   ├── card.tsx
    │   │   ├── CharacterCounter.tsx
    │   │   ├── dialog.tsx
    │   │   ├── dropdown-menu.tsx
    │   │   ├── FolderSelectManual.tsx
    │   │   ├── input.tsx
    │   │   ├── label.tsx
    │   │   ├── LoadingSpinnerStudy.tsx
    │   │   ├── skeleton.tsx
    │   │   ├── StudyControls.tsx
    │   │   ├── StudyFlashcard.tsx
    │   │   ├── StudyProgress.tsx
    │   │   └── textarea.tsx
    │   └── views/
    │       ├── DashboardView.tsx
    │       ├── DeleteFlashcardDialog.tsx
    │       ├── DeleteFolderDialog.tsx
    │       ├── EditFlashcardDialog.tsx
    │       ├── EditFolderDialog.tsx
    │       ├── FlashcardGeneratorForm.tsx
    │       ├── FlashcardList.tsx
    │       ├── FlashcardListItem.tsx
    │       ├── FlashcardProposalCard.tsx
    │       ├── FlashcardProposalList.tsx
    │       ├── FolderCard.tsx
    │       ├── FolderCardSkeleton.tsx
    │       ├── FolderGrid.tsx
    │       ├── FolderLoadingSpinner.tsx
    │       ├── FolderSelect.tsx
    │       ├── FolderView.tsx
    │       ├── GenerateFlashcardsView.tsx
    │       ├── LoadingSpinner.tsx
    │       ├── ManualSaveView.tsx
    │       └── StudySessionView.tsx
    ├── db/
    │   ├── database.types.ts
    │   └── supabase.client.ts
    ├── layouts/
    │   ├── AuthLayout.astro
    │   ├── GuestLayout.astro
    │   └── Layout.astro
    ├── lib/
    │   ├── utils.ts
    │   └── services/
    │       ├── flashcardService.ts
    │       ├── folderService.ts
    │       └── openRouterService.ts
    ├── middleware/
    │   └── index.ts
    ├── pages/
    │   ├── dashboard.astro
    │   ├── forgot-password.astro
    │   ├── generate.astro
    │   ├── index.astro
    │   ├── login.astro
    │   ├── manual-save.astro
    │   ├── password-reset.astro
    │   ├── register.astro
    │   ├── users.astro
    │   ├── api/
    │   │   ├── folders.ts
    │   │   ├── users.ts
    │   │   ├── auth/
    │   │   │   ├── login.ts
    │   │   │   ├── logout.ts
    │   │   │   └── register.ts
    │   │   ├── flashcards/
    │   │   │   ├── [flashcardId].ts
    │   │   │   ├── bulk-save.ts
    │   │   │   ├── generate.ts
    │   │   │   └── index.ts
    │   │   └── folders/
    │   │       └── [folderId].ts
    │   ├── folders/
    │   │   └── [folderId].astro
    │   └── study/
    │       └── [folderId].astro
    └── styles/
        └── global.css

================================================
FILE: src/env.d.ts
================================================
/// <reference types="astro/client" />

import type { SupabaseClient } from "@supabase/supabase-js";
import type { Database } from "./db/database.types";

declare global {
  namespace App {
    interface Locals {
      supabase: SupabaseClient<Database>;
      user?: {
        id: string;
        email: string;
      };
    }
  }
}

interface ImportMetaEnv {
  readonly SUPABASE_URL: string;
  readonly SUPABASE_KEY: string;
  readonly OPENROUTER_API_KEY: string;
  readonly AI_MODELNAME: string;
  // more env variables...
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}



================================================
FILE: src/types.ts
================================================
import type { Database } from './db/database.types';

// Base types extracted from the Supabase database definitions
export type Folder = Database["public"]["Tables"]["folders"]["Row"]; 
export type Flashcard = Database["public"]["Tables"]["flashcards"]["Row"];

// -----------------------------------------------------------
// DTO and Command Models Definitions for the API
// -----------------------------------------------------------

// 1. FOLDER

// DTO used for listing and retrieving folder details.
// For GET /folders and GET /folders/{folderId} endpoints.
// In 'Get Folder Details', we include an additional property 'flashcard_count'.
export interface FolderDTO extends Omit<Folder, 'user_id'> {
  // Optional field added for folder details endpoint
  flashcard_count?: number;
}

// Command Model for creating a new folder (POST /folders).
// The 'name' and 'user_id' fields are needed from the request.
export type CreateFolderCommand = Pick<Folder, 'name' | 'user_id'>;

// Command Model for updating an existing folder (PUT /folders/{folderId}).
// Payload requires a new name for the folder.
export type UpdateFolderCommand = Pick<Folder, 'name'>;

// -----------------------------------------------------------
// 2. FLASHCARDS

// DTO for flashcards used in listing and detailed retrieval (GET endpoints for flashcards).
// Excludes the internal 'user_id' field as it is managed from session context.
export interface FlashcardDTO extends Omit<Flashcard, 'user_id'> {}

// Command Model for creating a new flashcard (POST /flashcards).
// The payload must include 'front', 'back', 'folder_id', and 'generation_source'.
export type CreateFlashcardCommand = Pick<Flashcard, 'front' | 'back' | 'folder_id' | 'generation_source'>;

// Command Model for updating an existing flashcard (PUT /flashcards/{flashcardId}).
// The payload structure is similar to the creation command. Depending on the usage, you may allow partial updates.
export type UpdateFlashcardCommand = Pick<Flashcard, 'front' | 'back' | 'generation_source'> & {
  folder_id?: string; // Optional for updates - allows moving flashcard to different folder
};

// Command Model for generating flashcards via AI (POST /flashcards/generate).
// Receives a text input and returns a suggested folder name and a list of flashcard proposals.
export type GenerateFlashcardsCommand = {
  text: string;
};

// DTO representing the response from the AI flashcard generation endpoint.
export interface GenerateFlashcardsResponseDTO {
  suggested_folder_name: string;
  flashcards_proposals: Array<{
    front: string;
    back: string;
    generation_source: 'ai';
  }>;
}

// Command Model for bulk saving accepted flashcards (POST /flashcards/bulk-save).
// Payload includes the target folder ID and an array of flashcards.
// user_id is obtained from session by the backend.
export type BulkSaveFlashcardsCommand = {
  folder_id: string;
  flashcards: Array<{
    front: string;
    back: string;
    generation_source: 'ai';
  }>;
};

// -----------------------------------------------------------
// 3. VIEW MODELS FOR UI STATE MANAGEMENT

// ViewModel type for managing UI state of flashcard proposals during generation flow
export interface FlashcardProposalViewModel {
  id: string; // Unique client-side identifier (e.g., UUID)
  front: string;
  back: string;
  generation_source: 'ai';
  status: 'pending' | 'accepted' | 'rejected'; // User acceptance state
}

// ViewModel for folder, used in Dashboard view.
// Combines basic folder data with flashcard count.
export interface FolderViewModel {
  id: string;
  name: string;
  created_at: string;
  updated_at: string;
  flashcard_count: number;
}

// -----------------------------------------------------------
// 4. PAGINATION AND FOLDER VIEW MODELS

// Pagination structure for list endpoints
export interface Pagination {
  page: number;
  limit: number;
  total: number;
  totalPages: number;
}

// ViewModel for flashcard used in the folder view UI
export interface FlashcardViewModel {
  id: string;
  front: string;
  back: string;
  folder_id: string;
  generation_source: 'manual' | 'ai';
  created_at: string;
  updated_at: string;
}

// -----------------------------------------------------------
// 5. STUDY SESSION VIEW MODELS

// ViewModel for managing study session UI state
export interface StudySessionViewModel {
  flashcards: FlashcardViewModel[];
  currentCardIndex: number;
  knownFlashcards: number;
  status: 'loading' | 'studying' | 'finished';
  error: string | null;
}

// -----------------------------------------------------------
// Additional notes:
// - All DTOs directly derive from the underlying database entity types ensuring consistent structure.
// - Command Models use TypeScript utility types (Pick, Omit) to select only the necessary fields.
// - For update operations, both create and update commands share similar structure as per API requirements.



================================================
FILE: src/components/UsersList.tsx
================================================
[Binary file]


================================================
FILE: src/components/Welcome.astro
================================================
<div
  class="relative w-full mx-auto min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-blue-900 p-4 sm:p-8"
>
  <div
    class="relative max-w-4xl mx-auto backdrop-blur-xl bg-gradient-to-b from-white/10 to-white/5 rounded-2xl shadow-2xl p-8 text-white border border-white/10"
  >
    <div class="space-y-8">
      <div class="text-center">
        <h1
          class="text-6xl font-bold mb-4 bg-gradient-to-r from-blue-200 via-purple-200 to-pink-200 text-transparent bg-clip-text drop-shadow-lg"
        >
          Witaj w 10x Cards Flipper!
        </h1>
        <p class="text-xl text-blue-100/90 drop-shadow-md">
          Ten projekt został zbudowany w oparciu o nowoczesny stack technologiczny:
        </p>
      </div>

      <div class="flex flex-col gap-6 max-w-2xl mx-auto">
        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Core
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Astro v5.5.5</span>
              <span class="text-blue-100/90">- Metaframework do aplikacji webowych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">React v19</span>
              <span class="text-blue-100/90">- Biblioteka UI do komponentów interaktywnych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">TypeScript</span>
              <span class="text-blue-100/90">- Typowanie statyczne</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Stylowanie
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Tailwind CSS v4</span
              >
              <span class="text-blue-100/90">- Utility-first CSS framework</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Statyczna analiza kodu
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">ESLint v9</span>
              <span class="text-blue-100/90">- Lintowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Prettier</span>
              <span class="text-blue-100/90">- Formatowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Husky i Lint-staged</span
              >
              <span class="text-blue-100/90">- Automatyczna analiza kodu przed commitowaniem</span>
            </li>
          </ul>
        </div>
      </div>

      <p class="text-lg text-center text-blue-100/90 mt-8 leading-relaxed">
        Starter zawiera wszystko, czego potrzebujesz do rozpoczęcia tworzenia <br class="hidden sm:block" />
        <span class="font-semibold bg-gradient-to-r from-blue-200 to-purple-200 text-transparent bg-clip-text"
          >nowoczesnych aplikacji webowych!</span
        >
      </p>
    </div>
  </div>
</div>



================================================
FILE: src/components/auth/ForgotPasswordForm.tsx
================================================
import React, { useState, useCallback } from 'react';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Label } from '../ui/label';

interface ForgotPasswordFormViewModel {
  email: string;
}

interface ValidationErrors {
  email?: string;
  general?: string;
}

const ForgotPasswordForm: React.FC = () => {
  const [formData, setFormData] = useState<ForgotPasswordFormViewModel>({
    email: '',
  });

  const [validationErrors, setValidationErrors] = useState<ValidationErrors>({});
  const [isLoading, setIsLoading] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);

  // Walidacja email
  const validateEmail = useCallback((email: string): string | undefined => {
    if (!email.trim()) {
      return 'Email jest wymagany';
    }
    
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return 'Wprowadź poprawny adres email';
    }
    
    return undefined;
  }, []);

  // Sprawdź czy formularz jest valid
  const isFormValid = (): boolean => {
    return validateEmail(formData.email) === undefined;
  };

  // Obsługa zmiany wartości pól
  const handleFieldChange = useCallback((value: string) => {
    setFormData({ email: value });
    
    // Walidacja w czasie rzeczywistym
    const error = validateEmail(value);
    setValidationErrors(prev => ({
      ...prev,
      email: error,
      general: undefined, // Wyczyść błąd globalny przy zmianie danych
    }));
  }, [validateEmail]);

  // Obsługa blur - walidacja po opuszczeniu pola
  const handleBlur = useCallback(() => {
    const error = validateEmail(formData.email);
    setValidationErrors(prev => ({
      ...prev,
      email: error,
    }));
  }, [formData.email, validateEmail]);

  // Obsługa wysłania formularza
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!isFormValid()) {
      setValidationErrors({
        email: validateEmail(formData.email),
      });
      return;
    }
    
    setIsLoading(true);
    setValidationErrors({});
    
    try {
      // TODO: Implementacja odzyskiwania hasła z Supabase
      // await supabase.auth.resetPasswordForEmail(formData.email.trim(), {
      //   redirectTo: `${window.location.origin}/password-reset`,
      // });
      
      // Symulacja wywołania API
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      setIsSuccess(true);
      console.log('Link resetujący wysłany na:', formData.email);
      
    } catch (error) {
      console.error('Error during password reset:', error);
      setValidationErrors({
        general: error instanceof Error 
          ? error.message 
          : 'Wystąpił błąd podczas wysyłania linku resetującego'
      });
    } finally {
      setIsLoading(false);
    }
  };

  // Formularz sukcesu
  if (isSuccess) {
    return (
      <div className="space-y-6">
        <div className="space-y-2 text-center">
          <h1 className="text-2xl font-bold">Link został wysłany</h1>
          <p className="text-muted-foreground">
            Jeśli konto z podanym adresem email istnieje, został na nie wysłany link do resetowania hasła.
          </p>
        </div>

        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <p className="text-sm text-green-700">
            Sprawdź swoją skrzynkę pocztową i kliknij w link, aby zresetować hasło.
            Link jest ważny przez 1 godzinę.
          </p>
        </div>

        <div className="text-center space-y-4">
          <a href="/login" className="block text-primary hover:underline">
            Wróć do logowania
          </a>
          <button
            onClick={() => {
              setIsSuccess(false);
              setFormData({ email: '' });
            }}
            className="text-sm text-muted-foreground hover:text-foreground"
          >
            Wyślij ponownie
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="space-y-2 text-center">
        <h1 className="text-2xl font-bold">Resetuj hasło</h1>
        <p className="text-muted-foreground">
          Wprowadź swój adres email, a wyślemy Ci link do resetowania hasła
        </p>
      </div>

      <form onSubmit={handleSubmit} className="space-y-4">
        {/* Pole email */}
        <div className="space-y-2">
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            value={formData.email}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => 
              handleFieldChange(e.target.value)
            }
            onBlur={handleBlur}
            placeholder="twoj.email@example.com"
            className={validationErrors.email ? 'border-red-500' : ''}
            disabled={isLoading}
            autoComplete="email"
          />
          {validationErrors.email && (
            <span className="text-sm text-red-600">{validationErrors.email}</span>
          )}
        </div>

        {/* Błąd globalny */}
        {validationErrors.general && (
          <div className="bg-red-50 border border-red-200 rounded-lg p-3">
            <p className="text-sm text-red-700">{validationErrors.general}</p>
          </div>
        )}

        {/* Przycisk wysłania */}
        <Button
          type="submit"
          disabled={!isFormValid() || isLoading}
          className="w-full"
        >
          {isLoading ? 'Wysyłanie...' : 'Wyślij link resetujący'}
        </Button>
      </form>

      {/* Link powrotu do logowania */}
      <div className="text-center text-sm">
        <a href="/login" className="text-primary hover:underline">
          Wróć do logowania
        </a>
      </div>
    </div>
  );
};

export default ForgotPasswordForm;


================================================
FILE: src/components/auth/index.ts
================================================
export { default as LoginForm } from './LoginForm';
export { default as RegisterForm } from './RegisterForm';
export { default as ForgotPasswordForm } from './ForgotPasswordForm';
export { default as ResetPasswordForm } from './ResetPasswordForm';


================================================
FILE: src/components/auth/LoginForm.tsx
================================================
import React, { useState, useCallback } from 'react';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Label } from '../ui/label';

interface LoginFormViewModel {
  email: string;
  password: string;
}

interface ValidationErrors {
  email?: string;
  password?: string;
  general?: string;
}

const LoginForm: React.FC = () => {
  const [formData, setFormData] = useState<LoginFormViewModel>({
    email: '',
    password: '',
  });

  const [validationErrors, setValidationErrors] = useState<ValidationErrors>({});
  const [isLoading, setIsLoading] = useState(false);

  // Walidacja email
  const validateEmail = useCallback((email: string): string | undefined => {
    if (!email.trim()) {
      return 'Email jest wymagany';
    }
    
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return 'Wprowadź poprawny adres email';
    }
    
    return undefined;
  }, []);

  // Walidacja hasła
  const validatePassword = useCallback((password: string): string | undefined => {
    if (!password.trim()) {
      return 'Hasło jest wymagane';
    }
    
    return undefined;
  }, []);

  // Sprawdź czy formularz jest valid
  const isFormValid = (): boolean => {
    const emailValid = validateEmail(formData.email) === undefined;
    const passwordValid = validatePassword(formData.password) === undefined;
    
    return emailValid && passwordValid;
  };

  // Obsługa zmiany wartości pól
  const handleFieldChange = useCallback((field: keyof LoginFormViewModel, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    
    // Walidacja w czasie rzeczywistym
    let error: string | undefined;
    if (field === 'email') {
      error = validateEmail(value);
    } else if (field === 'password') {
      error = validatePassword(value);
    }
    
    setValidationErrors(prev => ({
      ...prev,
      [field]: error,
      general: undefined, // Wyczyść błąd globalny przy zmianie danych
    }));
  }, [validateEmail, validatePassword]);

  // Obsługa blur - walidacja po opuszczeniu pola
  const handleBlur = useCallback((field: keyof LoginFormViewModel) => {
    const value = formData[field];
    let error: string | undefined;
    
    if (field === 'email') {
      error = validateEmail(value);
    } else if (field === 'password') {
      error = validatePassword(value);
    }
    
    setValidationErrors(prev => ({
      ...prev,
      [field]: error,
    }));
  }, [formData, validateEmail, validatePassword]);

  // Obsługa wysłania formularza
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!isFormValid()) {
      // Pokazuj wszystkie błędy walidacji
      setValidationErrors({
        email: validateEmail(formData.email),
        password: validatePassword(formData.password),
      });
      return;
    }
    
    setIsLoading(true);
    setValidationErrors({});
    
    try {
      // Wysłanie żądania do API logowania
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: formData.email.trim(),
          password: formData.password,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Nieprawidłowy email lub hasło');
      }

      // Przekieruj do dashboardu po pomyślnym logowaniu
      window.location.href = '/dashboard';
      
    } catch (error) {
      console.error('Error during login:', error);
      setValidationErrors({
        general: error instanceof Error 
          ? error.message 
          : 'Nieprawidłowy email lub hasło'
      });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="space-y-6">
      <div className="space-y-2 text-center">
        <h1 className="text-2xl font-bold">Zaloguj się</h1>
        <p className="text-muted-foreground">
          Wprowadź swoje dane, aby uzyskać dostęp do konta
        </p>
      </div>

      <form onSubmit={handleSubmit} className="space-y-4">
        {/* Pole email */}
        <div className="space-y-2">
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            value={formData.email}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => 
              handleFieldChange('email', e.target.value)
            }
            onBlur={() => handleBlur('email')}
            placeholder="twoj.email@example.com"
            className={validationErrors.email ? 'border-red-500' : ''}
            disabled={isLoading}
            autoComplete="email"
          />
          {validationErrors.email && (
            <span className="text-sm text-red-600">{validationErrors.email}</span>
          )}
        </div>

        {/* Pole hasła */}
        <div className="space-y-2">
          <Label htmlFor="password">Hasło</Label>
          <Input
            id="password"
            type="password"
            value={formData.password}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => 
              handleFieldChange('password', e.target.value)
            }
            onBlur={() => handleBlur('password')}
            placeholder="Wprowadź hasło"
            className={validationErrors.password ? 'border-red-500' : ''}
            disabled={isLoading}
            autoComplete="current-password"
          />
          {validationErrors.password && (
            <span className="text-sm text-red-600">{validationErrors.password}</span>
          )}
        </div>

        {/* Błąd globalny */}
        {validationErrors.general && (
          <div className="bg-red-50 border border-red-200 rounded-lg p-3">
            <p className="text-sm text-red-700">{validationErrors.general}</p>
          </div>
        )}

        {/* Przycisk logowania */}
        <Button
          type="submit"
          disabled={!isFormValid() || isLoading}
          className="w-full"
        >
          {isLoading ? 'Logowanie...' : 'Zaloguj się'}
        </Button>

        {/* Link do odzyskiwania hasła */}
        {/* <div className="text-center">
          <a 
            href="/forgot-password" 
            className="text-sm text-primary hover:underline"
          >
            Zapomniałeś hasła?
          </a>
        </div> */}
      </form>

      {/* Link do rejestracji */}
      <div className="text-center text-sm">
        <span className="text-muted-foreground">Nie masz konta? </span>
        <a href="/register" className="text-primary hover:underline">
          Zarejestruj się
        </a>
      </div>
    </div>
  );
};

export default LoginForm;


================================================
FILE: src/components/auth/RegisterForm.tsx
================================================
import React, { useState, useCallback } from 'react';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Label } from '../ui/label';

interface RegisterFormViewModel {
  email: string;
  password: string;
  confirmPassword: string;
}

interface ValidationErrors {
  email?: string;
  password?: string;
  confirmPassword?: string;
  general?: string;
}

const RegisterForm: React.FC = () => {
  const [formData, setFormData] = useState<RegisterFormViewModel>({
    email: '',
    password: '',
    confirmPassword: '',
  });

  const [validationErrors, setValidationErrors] = useState<ValidationErrors>({});
  const [isLoading, setIsLoading] = useState(false);

  // Walidacja email
  const validateEmail = useCallback((email: string): string | undefined => {
    if (!email.trim()) {
      return 'Email jest wymagany';
    }
    
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return 'Wprowadź poprawny adres email';
    }
    
    return undefined;
  }, []);

  // Walidacja hasła
  const validatePassword = useCallback((password: string): string | undefined => {
    if (!password) {
      return 'Hasło jest wymagane';
    }
    
    if (password.length < 8) {
      return 'Hasło musi mieć minimum 8 znaków';
    }
    
    if (!/[A-Z]/.test(password)) {
      return 'Hasło musi zawierać co najmniej jedną wielką literę';
    }
    
    if (!/[0-9]/.test(password)) {
      return 'Hasło musi zawierać co najmniej jedną cyfrę';
    }
    
    if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
      return 'Hasło musi zawierać co najmniej jeden znak specjalny';
    }
    
    return undefined;
  }, []);

  // Walidacja potwierdzenia hasła
  const validateConfirmPassword = useCallback((confirmPassword: string, password: string): string | undefined => {
    if (!confirmPassword) {
      return 'Potwierdzenie hasła jest wymagane';
    }
    
    if (confirmPassword !== password) {
      return 'Hasła muszą być identyczne';
    }
    
    return undefined;
  }, []);

  // Sprawdź czy formularz jest valid
  const isFormValid = (): boolean => {
    const emailValid = validateEmail(formData.email) === undefined;
    const passwordValid = validatePassword(formData.password) === undefined;
    const confirmPasswordValid = validateConfirmPassword(formData.confirmPassword, formData.password) === undefined;
    
    return emailValid && passwordValid && confirmPasswordValid;
  };

  // Obsługa zmiany wartości pól
  const handleFieldChange = useCallback((field: keyof RegisterFormViewModel, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    
    // Walidacja w czasie rzeczywistym
    let error: string | undefined;
    if (field === 'email') {
      error = validateEmail(value);
    } else if (field === 'password') {
      error = validatePassword(value);
      // Również zwaliduj potwierdzenie hasła jeśli już zostało wprowadzone
      if (formData.confirmPassword) {
        setValidationErrors(prev => ({
          ...prev,
          confirmPassword: validateConfirmPassword(formData.confirmPassword, value),
        }));
      }
    } else if (field === 'confirmPassword') {
      error = validateConfirmPassword(value, formData.password);
    }
    
    setValidationErrors(prev => ({
      ...prev,
      [field]: error,
      general: undefined, // Wyczyść błąd globalny przy zmianie danych
    }));
  }, [formData.confirmPassword, formData.password, validateEmail, validatePassword, validateConfirmPassword]);

  // Obsługa blur - walidacja po opuszczeniu pola
  const handleBlur = useCallback((field: keyof RegisterFormViewModel) => {
    const value = formData[field];
    let error: string | undefined;
    
    if (field === 'email') {
      error = validateEmail(value);
    } else if (field === 'password') {
      error = validatePassword(value);
    } else if (field === 'confirmPassword') {
      error = validateConfirmPassword(value, formData.password);
    }
    
    setValidationErrors(prev => ({
      ...prev,
      [field]: error,
    }));
  }, [formData, validateEmail, validatePassword, validateConfirmPassword]);

  // Obsługa wysłania formularza
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!isFormValid()) {
      // Pokazuj wszystkie błędy walidacji
      setValidationErrors({
        email: validateEmail(formData.email),
        password: validatePassword(formData.password),
        confirmPassword: validateConfirmPassword(formData.confirmPassword, formData.password),
      });
      return;
    }
    
    setIsLoading(true);
    setValidationErrors({});
    
    try {
      // Wywołanie API endpoint rejestracji
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: formData.email.trim(),
          password: formData.password,
          confirmPassword: formData.confirmPassword,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        // Obsługa błędów z serwera
        setValidationErrors({
          [data.field || 'general']: data.error || 'Wystąpił błąd podczas rejestracji',
        });
        return;
      }

      // Rejestracja pomyślna - użytkownik jest automatycznie zalogowany
      // Przekieruj do dashboardu
      window.location.href = '/dashboard';
      
    } catch (error) {
      console.error('Error during registration:', error);
      setValidationErrors({
        general: 'Wystąpił błąd połączenia. Sprawdź swoje połączenie internetowe i spróbuj ponownie.'
      });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="space-y-6">
      <div className="space-y-2 text-center">
        <h1 className="text-2xl font-bold">Utwórz konto</h1>
        <p className="text-muted-foreground">
          Wprowadź swoje dane, aby utworzyć nowe konto
        </p>
      </div>

      <form onSubmit={handleSubmit} className="space-y-4">
        {/* Pole email */}
        <div className="space-y-2">
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            value={formData.email}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => 
              handleFieldChange('email', e.target.value)
            }
            onBlur={() => handleBlur('email')}
            placeholder="twoj.email@example.com"
            className={validationErrors.email ? 'border-red-500' : ''}
            disabled={isLoading}
            autoComplete="email"
          />
          {validationErrors.email && (
            <span className="text-sm text-red-600">{validationErrors.email}</span>
          )}
        </div>

        {/* Pole hasła */}
        <div className="space-y-2">
          <Label htmlFor="password">Hasło</Label>
          <Input
            id="password"
            type="password"
            value={formData.password}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => 
              handleFieldChange('password', e.target.value)
            }
            onBlur={() => handleBlur('password')}
            placeholder="Wprowadź hasło"
            className={validationErrors.password ? 'border-red-500' : ''}
            disabled={isLoading}
            autoComplete="new-password"
          />
          {validationErrors.password && (
            <span className="text-sm text-red-600">{validationErrors.password}</span>
          )}
          {/* Wskazówki dotyczące hasła */}
          <div className="text-xs text-muted-foreground space-y-1">
            <p>Hasło musi zawierać:</p>
            <ul className="list-disc list-inside space-y-1 ml-2">
              <li>Co najmniej 8 znaków</li>
              <li>Co najmniej jedną wielką literę</li>
              <li>Co najmniej jedną cyfrę</li>
              <li>Co najmniej jeden znak specjalny</li>
            </ul>
          </div>
        </div>

        {/* Pole potwierdzenia hasła */}
        <div className="space-y-2">
          <Label htmlFor="confirmPassword">Powtórz hasło</Label>
          <Input
            id="confirmPassword"
            type="password"
            value={formData.confirmPassword}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => 
              handleFieldChange('confirmPassword', e.target.value)
            }
            onBlur={() => handleBlur('confirmPassword')}
            placeholder="Powtórz hasło"
            className={validationErrors.confirmPassword ? 'border-red-500' : ''}
            disabled={isLoading}
            autoComplete="new-password"
          />
          {validationErrors.confirmPassword && (
            <span className="text-sm text-red-600">{validationErrors.confirmPassword}</span>
          )}
        </div>

        {/* Błąd globalny */}
        {validationErrors.general && (
          <div className="bg-red-50 border border-red-200 rounded-lg p-3">
            <p className="text-sm text-red-700">{validationErrors.general}</p>
          </div>
        )}

        {/* Przycisk rejestracji */}
        <Button
          type="submit"
          disabled={!isFormValid() || isLoading}
          className="w-full"
        >
          {isLoading ? 'Tworzenie konta...' : 'Utwórz konto'}
        </Button>
      </form>

      {/* Link do logowania */}
      <div className="text-center text-sm">
        <span className="text-muted-foreground">Masz już konto? </span>
        <a href="/login" className="text-primary hover:underline">
          Zaloguj się
        </a>
      </div>
    </div>
  );
};

export default RegisterForm;


================================================
FILE: src/components/auth/ResetPasswordForm.tsx
================================================
import React, { useState, useCallback } from 'react';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Label } from '../ui/label';

interface ResetPasswordFormViewModel {
  password: string;
  confirmPassword: string;
}

interface ValidationErrors {
  password?: string;
  confirmPassword?: string;
  general?: string;
}

const ResetPasswordForm: React.FC = () => {
  const [formData, setFormData] = useState<ResetPasswordFormViewModel>({
    password: '',
    confirmPassword: '',
  });

  const [validationErrors, setValidationErrors] = useState<ValidationErrors>({});
  const [isLoading, setIsLoading] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);

  // Walidacja hasła
  const validatePassword = useCallback((password: string): string | undefined => {
    if (!password) {
      return 'Hasło jest wymagane';
    }
    
    if (password.length < 8) {
      return 'Hasło musi mieć minimum 8 znaków';
    }
    
    if (!/[A-Z]/.test(password)) {
      return 'Hasło musi zawierać co najmniej jedną wielką literę';
    }
    
    if (!/[0-9]/.test(password)) {
      return 'Hasło musi zawierać co najmniej jedną cyfrę';
    }
    
    if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
      return 'Hasło musi zawierać co najmniej jeden znak specjalny';
    }
    
    return undefined;
  }, []);

  // Walidacja potwierdzenia hasła
  const validateConfirmPassword = useCallback((confirmPassword: string, password: string): string | undefined => {
    if (!confirmPassword) {
      return 'Potwierdzenie hasła jest wymagane';
    }
    
    if (confirmPassword !== password) {
      return 'Hasła muszą być identyczne';
    }
    
    return undefined;
  }, []);

  // Sprawdź czy formularz jest valid
  const isFormValid = (): boolean => {
    const passwordValid = validatePassword(formData.password) === undefined;
    const confirmPasswordValid = validateConfirmPassword(formData.confirmPassword, formData.password) === undefined;
    
    return passwordValid && confirmPasswordValid;
  };

  // Obsługa zmiany wartości pól
  const handleFieldChange = useCallback((field: keyof ResetPasswordFormViewModel, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    
    // Walidacja w czasie rzeczywistym
    let error: string | undefined;
    if (field === 'password') {
      error = validatePassword(value);
      // Również zwaliduj potwierdzenie hasła jeśli już zostało wprowadzone
      if (formData.confirmPassword) {
        setValidationErrors(prev => ({
          ...prev,
          confirmPassword: validateConfirmPassword(formData.confirmPassword, value),
        }));
      }
    } else if (field === 'confirmPassword') {
      error = validateConfirmPassword(value, formData.password);
    }
    
    setValidationErrors(prev => ({
      ...prev,
      [field]: error,
      general: undefined, // Wyczyść błąd globalny przy zmianie danych
    }));
  }, [formData.confirmPassword, formData.password, validatePassword, validateConfirmPassword]);

  // Obsługa blur - walidacja po opuszczeniu pola
  const handleBlur = useCallback((field: keyof ResetPasswordFormViewModel) => {
    const value = formData[field];
    let error: string | undefined;
    
    if (field === 'password') {
      error = validatePassword(value);
    } else if (field === 'confirmPassword') {
      error = validateConfirmPassword(value, formData.password);
    }
    
    setValidationErrors(prev => ({
      ...prev,
      [field]: error,
    }));
  }, [formData, validatePassword, validateConfirmPassword]);

  // Obsługa wysłania formularza
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!isFormValid()) {
      // Pokazuj wszystkie błędy walidacji
      setValidationErrors({
        password: validatePassword(formData.password),
        confirmPassword: validateConfirmPassword(formData.confirmPassword, formData.password),
      });
      return;
    }
    
    setIsLoading(true);
    setValidationErrors({});
    
    try {
      // TODO: Implementacja resetowania hasła z Supabase
      // await supabase.auth.updateUser({
      //   password: formData.password,
      // });
      
      // Symulacja wywołania API
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      setIsSuccess(true);
      console.log('Hasło zostało pomyślnie zresetowane');
      
    } catch (error) {
      console.error('Error during password reset:', error);
      setValidationErrors({
        general: error instanceof Error 
          ? error.message 
          : 'Wystąpił błąd podczas resetowania hasła'
      });
    } finally {
      setIsLoading(false);
    }
  };

  // Formularz sukcesu
  if (isSuccess) {
    return (
      <div className="space-y-6">
        <div className="space-y-2 text-center">
          <h1 className="text-2xl font-bold">Hasło zostało zmienione</h1>
          <p className="text-muted-foreground">
            Twoje hasło zostało pomyślnie zaktualizowane. 
            Możesz teraz zalogować się przy użyciu nowego hasła.
          </p>
        </div>

        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <p className="text-sm text-green-700">
            Hasło zostało pomyślnie zmienione. Ze względów bezpieczeństwa
            zostałeś wylogowany ze wszystkich urządzeń.
          </p>
        </div>

        <div className="text-center">
          <a href="/login">
            <Button className="w-full">
              Przejdź do logowania
            </Button>
          </a>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="space-y-2 text-center">
        <h1 className="text-2xl font-bold">Ustaw nowe hasło</h1>
        <p className="text-muted-foreground">
          Wprowadź nowe hasło dla swojego konta
        </p>
      </div>

      <form onSubmit={handleSubmit} className="space-y-4">
        {/* Pole nowego hasła */}
        <div className="space-y-2">
          <Label htmlFor="password">Nowe hasło</Label>
          <Input
            id="password"
            type="password"
            value={formData.password}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => 
              handleFieldChange('password', e.target.value)
            }
            onBlur={() => handleBlur('password')}
            placeholder="Wprowadź nowe hasło"
            className={validationErrors.password ? 'border-red-500' : ''}
            disabled={isLoading}
            autoComplete="new-password"
          />
          {validationErrors.password && (
            <span className="text-sm text-red-600">{validationErrors.password}</span>
          )}
          {/* Wskazówki dotyczące hasła */}
          <div className="text-xs text-muted-foreground space-y-1">
            <p>Hasło musi zawierać:</p>
            <ul className="list-disc list-inside space-y-1 ml-2">
              <li>Co najmniej 8 znaków</li>
              <li>Co najmniej jedną wielką literę</li>
              <li>Co najmniej jedną cyfrę</li>
              <li>Co najmniej jeden znak specjalny</li>
            </ul>
          </div>
        </div>

        {/* Pole potwierdzenia hasła */}
        <div className="space-y-2">
          <Label htmlFor="confirmPassword">Powtórz nowe hasło</Label>
          <Input
            id="confirmPassword"
            type="password"
            value={formData.confirmPassword}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => 
              handleFieldChange('confirmPassword', e.target.value)
            }
            onBlur={() => handleBlur('confirmPassword')}
            placeholder="Powtórz nowe hasło"
            className={validationErrors.confirmPassword ? 'border-red-500' : ''}
            disabled={isLoading}
            autoComplete="new-password"
          />
          {validationErrors.confirmPassword && (
            <span className="text-sm text-red-600">{validationErrors.confirmPassword}</span>
          )}
        </div>

        {/* Błąd globalny */}
        {validationErrors.general && (
          <div className="bg-red-50 border border-red-200 rounded-lg p-3">
            <p className="text-sm text-red-700">{validationErrors.general}</p>
          </div>
        )}

        {/* Przycisk resetowania */}
        <Button
          type="submit"
          disabled={!isFormValid() || isLoading}
          className="w-full"
        >
          {isLoading ? 'Resetowanie hasła...' : 'Resetuj hasło'}
        </Button>
      </form>

      {/* Link do logowania */}
      <div className="text-center text-sm">
        <a href="/login" className="text-primary hover:underline">
          Wróć do logowania
        </a>
      </div>
    </div>
  );
};

export default ResetPasswordForm;


================================================
FILE: src/components/forms/ManualFlashcardForm.tsx
================================================
import React, { useState } from 'react';
import type { Folder, CreateFlashcardCommand } from '../../types';
import { Button } from '../ui/button';
import { Textarea } from '../ui/textarea';
import { Label } from '../ui/label';
import FolderSelectManual from '../ui/FolderSelectManual';
import CharacterCounter from '../ui/CharacterCounter';

interface ManualFlashcardFormViewModel {
  front: string;
  back: string;
  folderId: string | null;
  newFolderName: string;
}

interface ManualFlashcardFormProps {
  folders: Folder[];
  isLoading: boolean;
  onSave: (command: CreateFlashcardCommand) => Promise<void>;
  onCreateFolder: (name: string) => Promise<Folder>;
}

interface ValidationErrors {
  front?: string;
  back?: string;
  folder?: string;
}

const ManualFlashcardForm: React.FC<ManualFlashcardFormProps> = ({
  folders,
  isLoading,
  onSave,
  onCreateFolder,
}) => {
  const [formData, setFormData] = useState<ManualFlashcardFormViewModel>({
    front: '',
    back: '',
    folderId: null,
    newFolderName: '',
  });

  const [validationErrors, setValidationErrors] = useState<ValidationErrors>({});
  const [isSaving, setIsSaving] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);

  // Walidacja pól formularza
  const validateField = (field: keyof ManualFlashcardFormViewModel, value: string): string | undefined => {
    switch (field) {
      case 'front':
        if (!value.trim()) {
          return 'Treść przodu fiszki jest wymagana';
        }
        if (value.length > 200) {
          return 'Treść przodu nie może przekraczać 200 znaków';
        }
        return undefined;
      
      case 'back':
        if (!value.trim()) {
          return 'Treść tyłu fiszki jest wymagana';
        }
        if (value.length > 500) {
          return 'Treść tyłu nie może przekraczać 500 znaków';
        }
        return undefined;
      
      default:
        return undefined;
    }
  };

  // Sprawdź czy formularz jest valid
  const isFormValid = (): boolean => {
    const frontValid = formData.front.trim().length > 0 && formData.front.length <= 200;
    const backValid = formData.back.trim().length > 0 && formData.back.length <= 500;
    const folderValid = formData.folderId !== null;
    
    return frontValid && backValid && folderValid;
  };

  // Obsługa zmiany wartości pól
  const handleFieldChange = (field: keyof ManualFlashcardFormViewModel, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    
    // Walidacja w czasie rzeczywistym
    const error = validateField(field, value);
    setValidationErrors(prev => ({
      ...prev,
      [field]: error,
    }));
    
    // Wyczyść błąd zapisu przy zmianie danych
    if (saveError) {
      setSaveError(null);
    }
  };

  // Obsługa wyboru folderu
  const handleFolderSelect = (folderId: string) => {
    setFormData(prev => ({ ...prev, folderId }));
    setValidationErrors(prev => ({ ...prev, folder: undefined }));
  };

  // Obsługa wysłania formularza
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!isFormValid()) {
      return;
    }
    
    setIsSaving(true);
    setSaveError(null);
    
    try {
      const command: CreateFlashcardCommand = {
        front: formData.front.trim(),
        back: formData.back.trim(),
        folder_id: formData.folderId!,
        generation_source: 'manual',
      };
      
      await onSave(command);
      
      // Wyczyść formularz po pomyślnym zapisie
      setFormData({
        front: '',
        back: '',
        folderId: null,
        newFolderName: '',
      });
      
      // Pokaż powiadomienie o sukcesie (do implementacji później)
      console.log('Fiszka została pomyślnie zapisana');
      
    } catch (error) {
      console.error('Error saving flashcard:', error);
      setSaveError(
        error instanceof Error 
          ? error.message 
          : 'Wystąpił błąd podczas zapisywania fiszki'
      );
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {/* Pole przód fiszki */}
      <div className="space-y-2">
        <Label htmlFor="front">Przód fiszki</Label>
        <Textarea
          id="front"
          value={formData.front}
          onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => handleFieldChange('front', e.target.value)}
          placeholder="Wprowadź treść przodu fiszki..."
          className={validationErrors.front ? 'border-red-500' : ''}
          rows={3}
        />
        <div className="flex justify-between items-center">
          <CharacterCounter 
            currentLength={formData.front.length} 
            maxLength={200} 
          />
          {validationErrors.front && (
            <span className="text-sm text-red-600">{validationErrors.front}</span>
          )}
        </div>
      </div>

      {/* Pole tył fiszki */}
      <div className="space-y-2">
        <Label htmlFor="back">Tył fiszki</Label>
        <Textarea
          id="back"
          value={formData.back}
          onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => handleFieldChange('back', e.target.value)}
          placeholder="Wprowadź treść tyłu fiszki..."
          className={validationErrors.back ? 'border-red-500' : ''}
          rows={4}
        />
        <div className="flex justify-between items-center">
          <CharacterCounter 
            currentLength={formData.back.length} 
            maxLength={500} 
          />
          {validationErrors.back && (
            <span className="text-sm text-red-600">{validationErrors.back}</span>
          )}
        </div>
      </div>

      {/* Wybór folderu */}
      <div className="space-y-2">
        <Label htmlFor="folder">Folder</Label>
        <FolderSelectManual
          folders={folders}
          selectedFolderId={formData.folderId}
          onSelect={handleFolderSelect}
          onCreateFolder={onCreateFolder}
          disabled={isLoading}
        />
        {validationErrors.folder && (
          <span className="text-sm text-red-600">{validationErrors.folder}</span>
        )}
      </div>

      {/* Błąd zapisu */}
      {saveError && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-3">
          <p className="text-sm text-red-700">{saveError}</p>
        </div>
      )}

      {/* Przycisk zapisu */}
      <div className="flex justify-end">
        <Button
          type="submit"
          disabled={!isFormValid() || isSaving || isLoading}
          className="min-w-[120px]"
        >
          {isSaving ? 'Zapisywanie...' : 'Zapisz fiszkę'}
        </Button>
      </div>
    </form>
  );
};

export default ManualFlashcardForm;


================================================
FILE: src/components/hooks/useDashboardState.ts
================================================
import { useState, useEffect, useCallback } from 'react';
import type { FolderViewModel } from '../../types';


interface UseDashboardStateReturn {
  // State
  folders: FolderViewModel[];
  isLoading: boolean;
  error: string | null;
  editingFolder: FolderViewModel | null;
  deletingFolder: FolderViewModel | null;
  
  // Actions
  handleRefresh: () => void;
  handleEditFolder: (folderId: string) => void;
  handleDeleteFolder: (folderId: string) => void;
  handleCloseEditDialog: () => void;
  handleCloseDeleteDialog: () => void;
  handleSaveFolder: (folderId: string, newName: string) => Promise<void>;
  handleConfirmDelete: (folderId: string) => Promise<void>;
}

/**
 * Custom hook for managing Dashboard state
 * Encapsulates logic for managing folders, loading, errors, and interactions with API
 * @param userId - The ID of the currently authenticated user
 */
export function useDashboardState(userId: string): UseDashboardStateReturn {
  const [folders, setFolders] = useState<FolderViewModel[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [editingFolder, setEditingFolder] = useState<FolderViewModel | null>(null);
  const [deletingFolder, setDeletingFolder] = useState<FolderViewModel | null>(null);

  /**
   * Fetches folders from API with flashcard counts (N+1 queries approach)
   * Step 1: Get list of folders
   * Step 2: For each folder, get details with flashcard count
   * Result: Array of FolderViewModel[]
   */
  const fetchFolders = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      // Step 1: Fetch list of folders
      const foldersResponse = await fetch(`/api/folders?user_id=${userId}&limit=50`);
      
      if (!foldersResponse.ok) {
        const errorData = await foldersResponse.json();
        throw new Error(errorData.message || 'Failed to fetch folders');
      }

      const foldersResult = await foldersResponse.json();
      
      if (!foldersResult.success) {
        throw new Error(foldersResult.message || 'Failed to fetch folders');
      }

      const foldersList = foldersResult.data.folders;

      // If no folders, return empty array
      if (!foldersList || foldersList.length === 0) {
        setFolders([]);
        return;
      }

      // Step 2: Fetch details for each folder (including flashcard count)
      const folderDetailsPromises = foldersList.map(async (folder: any) => {
        const detailsResponse = await fetch(`/api/folders/${folder.id}?user_id=${userId}`);
        
        if (!detailsResponse.ok) {
          // If details fetch fails, fallback to basic folder data with 0 count
          console.warn(`Failed to fetch details for folder ${folder.id}`);
          return {
            id: folder.id,
            name: folder.name,
            created_at: folder.created_at,
            updated_at: folder.updated_at,
            flashcard_count: 0,
          } as FolderViewModel;
        }

        const detailsResult = await detailsResponse.json();
        
        if (!detailsResult.success) {
          // If details fetch fails, fallback to basic folder data with 0 count
          console.warn(`Failed to fetch details for folder ${folder.id}: ${detailsResult.message}`);
          return {
            id: folder.id,
            name: folder.name,
            created_at: folder.created_at,
            updated_at: folder.updated_at,
            flashcard_count: 0,
          } as FolderViewModel;
        }

        return {
          id: detailsResult.data.id,
          name: detailsResult.data.name,
          created_at: detailsResult.data.created_at,
          updated_at: detailsResult.data.updated_at,
          flashcard_count: detailsResult.data.flashcard_count || 0,
        } as FolderViewModel;
      });

      const foldersWithDetails = await Promise.all(folderDetailsPromises);
      setFolders(foldersWithDetails);

    } catch (err) {
      console.error('Error fetching folders:', err);
      setError(err instanceof Error ? err.message : 'An unexpected error occurred');
    } finally {
      setIsLoading(false);
    }
  }, [userId]);

  /**
   * Initialize data loading on component mount
   */
  useEffect(() => {
    fetchFolders();
  }, [fetchFolders]);

  /**
   * Handle refresh action - refetch all folders
   */
  const handleRefresh = useCallback(() => {
    fetchFolders();
  }, [fetchFolders]);

  /**
   * Handle edit folder action - open edit dialog
   */
  const handleEditFolder = useCallback((folderId: string) => {
    const folder = folders.find(f => f.id === folderId);
    if (folder) {
      setEditingFolder(folder);
    }
  }, [folders]);

  /**
   * Handle delete folder action - open delete confirmation dialog
   */
  const handleDeleteFolder = useCallback((folderId: string) => {
    const folder = folders.find(f => f.id === folderId);
    if (folder) {
      setDeletingFolder(folder);
    }
  }, [folders]);

  /**
   * Close edit dialog
   */
  const handleCloseEditDialog = useCallback(() => {
    setEditingFolder(null);
  }, []);

  /**
   * Close delete confirmation dialog
   */
  const handleCloseDeleteDialog = useCallback(() => {
    setDeletingFolder(null);
  }, []);

  /**
   * Save folder name changes
   */
  const handleSaveFolder = useCallback(async (folderId: string, newName: string) => {
    try {
      const response = await fetch(`/api/folders/${folderId}?user_id=${userId}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ name: newName }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to update folder');
      }

      const result = await response.json();
      
      if (!result.success) {
        throw new Error(result.message || 'Failed to update folder');
      }

      // Update local state with new folder data
      setFolders(prevFolders => 
        prevFolders.map(folder => 
          folder.id === folderId 
            ? { ...folder, name: newName, updated_at: result.data.updated_at }
            : folder
        )
      );

      // Close edit dialog
      setEditingFolder(null);

    } catch (err) {
      console.error('Error updating folder:', err);
      throw err; // Re-throw to let the component handle the error display
    }
  }, [userId]);

  /**
   * Confirm folder deletion
   */
  const handleConfirmDelete = useCallback(async (folderId: string) => {
    try {
      const response = await fetch(`/api/folders/${folderId}?user_id=${userId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to delete folder');
      }

      const result = await response.json();
      
      if (!result.success) {
        throw new Error(result.message || 'Failed to delete folder');
      }

      // Remove folder from local state
      setFolders(prevFolders => prevFolders.filter(folder => folder.id !== folderId));

      // Close delete dialog
      setDeletingFolder(null);

    } catch (err) {
      console.error('Error deleting folder:', err);
      throw err; // Re-throw to let the component handle the error display
    }
  }, [userId]);

  return {
    folders,
    isLoading,
    error,
    editingFolder,
    deletingFolder,
    handleRefresh,
    handleEditFolder,
    handleDeleteFolder,
    handleCloseEditDialog,
    handleCloseDeleteDialog,
    handleSaveFolder,
    handleConfirmDelete,
  };
}


================================================
FILE: src/components/ui/avatar.tsx
================================================
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }



================================================
FILE: src/components/ui/button.tsx
================================================
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "../../lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : "button";

  return <Comp data-slot="button" className={cn(buttonVariants({ variant, size, className }))} {...props} />;
}

export { Button, buttonVariants };



================================================
FILE: src/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}



================================================
FILE: src/components/ui/CharacterCounter.tsx
================================================
import React from 'react';
import { cn } from '../../lib/utils';

interface CharacterCounterProps {
  currentLength: number;
  maxLength: number;
  className?: string;
}

const CharacterCounter: React.FC<CharacterCounterProps> = ({
  currentLength,
  maxLength,
  className,
}) => {
  const isOverLimit = currentLength > maxLength;
  const isNearLimit = currentLength > maxLength * 0.8;

  return (
    <span
      className={cn(
        'text-sm',
        {
          'text-red-600': isOverLimit,
          'text-amber-600': !isOverLimit && isNearLimit,
          'text-gray-500': !isOverLimit && !isNearLimit,
        },
        className
      )}
    >
      {currentLength}/{maxLength}
    </span>
  );
};

export default CharacterCounter;


================================================
FILE: src/components/ui/dialog.tsx
================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  asChild,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      asChild={asChild}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}



================================================
FILE: src/components/ui/dropdown-menu.tsx
================================================
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}



================================================
FILE: src/components/ui/FolderSelectManual.tsx
================================================
import React, { useState } from 'react';
import { Button } from './button';
import { Card, CardContent } from './card';
import { Input } from './input';
import { Label } from './label';
import type { Folder } from '../../types';

interface FolderSelectProps {
  folders: Folder[];
  selectedFolderId: string | null;
  onSelect: (folderId: string) => void;
  onCreateFolder: (name: string) => Promise<Folder>;
  disabled?: boolean;
}

const FolderSelectManual: React.FC<FolderSelectProps> = ({
  folders = [],
  selectedFolderId,
  onSelect,
  onCreateFolder,
  disabled = false,
}) => {
  const [mode, setMode] = useState<'existing' | 'new'>('existing');
  const [newFolderName, setNewFolderName] = useState('');
  const [isCreating, setIsCreating] = useState(false);
  const [createError, setCreateError] = useState<string | null>(null);

  // Bezpieczna lista folderów
  const safeFolders = Array.isArray(folders) ? folders : [];

  // Obsługa tworzenia nowego folderu
  const handleCreateFolder = async () => {
    if (!newFolderName.trim()) return;

    setIsCreating(true);
    setCreateError(null);

    try {
      const newFolder = await onCreateFolder(newFolderName.trim());
      console.log('Created folder:', newFolder);
      onSelect(newFolder.id);
      setNewFolderName('');
      setMode('existing');
    } catch (error) {
      console.error('Error creating folder:', error);
      setCreateError(
        error instanceof Error 
          ? error.message 
          : 'Wystąpił błąd podczas tworzenia folderu'
      );
    } finally {
      setIsCreating(false);
    }
  };

  // Sprawdź czy nazwa folderu już istnieje
  const folderNameExists = safeFolders.some(
    folder => folder.name.toLowerCase() === newFolderName.trim().toLowerCase()
  );

  // Walidacja nazwy nowego folderu
  const isNewFolderNameValid = newFolderName.trim().length > 0 && 
                              newFolderName.trim().length <= 100 && 
                              !folderNameExists;

  return (
    <div className="space-y-4">
      {/* Przełącznik trybu */}
      <div className="flex space-x-2">
        <Button
          type="button"
          variant={mode === 'existing' ? 'default' : 'outline'}
          size="sm"
          onClick={() => setMode('existing')}
          disabled={disabled || safeFolders.length === 0}
        >
          Wybierz istniejący
        </Button>
        <Button
          type="button"
          variant={mode === 'new' ? 'default' : 'outline'}
          size="sm"
          onClick={() => setMode('new')}
          disabled={disabled}
        >
          Utwórz nowy
        </Button>
      </div>

      {/* Wybór istniejącego folderu */}
      {mode === 'existing' && (
        <Card>
          <CardContent className="pt-4">
            {safeFolders.length === 0 ? (
              <div className="text-center py-4">
                <p className="text-gray-500 mb-3">
                  Nie masz jeszcze żadnych folderów.
                </p>
                <Button
                  type="button"
                  onClick={() => setMode('new')}
                  disabled={disabled}
                  size="sm"
                >
                  Utwórz pierwszy folder
                </Button>
              </div>
            ) : (
              <div className="space-y-2">
                <Label>Wybierz folder:</Label>
                <div className="grid gap-2 max-h-48 overflow-y-auto">
                  {safeFolders.map((folder) => (
                    <Button
                      key={folder.id}
                      type="button"
                      variant={selectedFolderId === folder.id ? 'default' : 'outline'}
                      className="justify-start text-left h-auto py-3"
                      onClick={() => onSelect(folder.id)}
                      disabled={disabled}
                    >
                      <div className="flex items-center justify-between w-full">
                        <span className="truncate font-medium">{folder.name}</span>
                        <span className="text-xs text-muted-foreground ml-2 flex-shrink-0">
                          {folder.created_at ? new Date(folder.created_at).toLocaleDateString() : ''}
                        </span>
                      </div>
                    </Button>
                  ))}
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      )}

      {/* Tworzenie nowego folderu */}
      {mode === 'new' && (
        <Card>
          <CardContent className="pt-4">
            <div className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="new-folder-name">Nazwa nowego folderu:</Label>
                <Input
                  id="new-folder-name"
                  type="text"
                  value={newFolderName}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                    setNewFolderName(e.target.value);
                    setCreateError(null);
                  }}
                  placeholder="Wprowadź nazwę folderu..."
                  disabled={disabled || isCreating}
                  maxLength={100}
                  className={folderNameExists ? 'border-red-500' : ''}
                />
                
                {/* Licznik znaków */}
                <div className="flex justify-between items-center text-xs">
                  <span className={newFolderName.length > 100 ? 'text-red-600' : 'text-gray-500'}>
                    {newFolderName.length} / 100 znaków
                  </span>
                </div>

                {/* Błędy walidacji */}
                {folderNameExists && (
                  <p className="text-xs text-red-600">
                    Folder o tej nazwie już istnieje
                  </p>
                )}
                
                {createError && (
                  <p className="text-xs text-red-600">
                    {createError}
                  </p>
                )}
              </div>

              <div className="flex justify-end space-x-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => {
                    setMode('existing');
                    setNewFolderName('');
                    setCreateError(null);
                  }}
                  disabled={disabled || isCreating}
                  size="sm"
                >
                  Anuluj
                </Button>
                <Button
                  type="button"
                  onClick={handleCreateFolder}
                  disabled={disabled || isCreating || !isNewFolderNameValid}
                  size="sm"
                >
                  {isCreating ? 'Tworzenie...' : 'Utwórz folder'}
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Komunikat o braku wyboru dla istniejących folderów */}
      {mode === 'existing' && !selectedFolderId && safeFolders.length > 0 && (
        <p className="text-xs text-red-600">
          Wybierz folder z listy
        </p>
      )}
    </div>
  );
};

export default FolderSelectManual;


================================================
FILE: src/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "../../lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }



================================================
FILE: src/components/ui/label.tsx
================================================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "../../lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }



================================================
FILE: src/components/ui/LoadingSpinnerStudy.tsx
================================================
export default function LoadingSpinnerStudy() {
  return (
    <div className="flex flex-col items-center justify-center space-y-4 py-12">
      <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
      <div className="text-center space-y-2">
        <h2 className="text-xl font-semibold">Przygotowywanie sesji nauki...</h2>
        <p className="text-muted-foreground">Pobieranie fiszek z folderu</p>
      </div>
    </div>
  );
}


================================================
FILE: src/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: src/components/ui/StudyControls.tsx
================================================
import { Button } from '@/components/ui/button';

interface StudyControlsProps {
  onKnowClick: () => void;
  onDontKnowClick: () => void;
}

export default function StudyControls({ onKnowClick, onDontKnowClick }: StudyControlsProps) {
  return (
    <div className="flex flex-col sm:flex-row gap-4 justify-center">
      <Button 
        onClick={onDontKnowClick}
        variant="outline"
        size="lg"
        className="min-w-[140px] w-full sm:w-auto border-destructive text-destructive hover:bg-destructive hover:text-destructive-foreground transition-all duration-200 hover:scale-105"
      >
        <span className="mr-2">✗</span>
        Nie znam
      </Button>
      
      <Button 
        onClick={onKnowClick}
        variant="default"
        size="lg"
        className="min-w-[140px] w-full sm:w-auto bg-green-600 hover:bg-green-700 transition-all duration-200 hover:scale-105"
      >
        <span className="mr-2">✓</span>
        Znam
      </Button>
    </div>
  );
}


================================================
FILE: src/components/ui/StudyFlashcard.tsx
================================================
import { useState, useEffect } from 'react';
import type { FlashcardViewModel } from '@/types';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';

interface StudyFlashcardProps {
  flashcard: FlashcardViewModel;
}

export default function StudyFlashcard({ flashcard }: StudyFlashcardProps) {
  const [isFlipped, setIsFlipped] = useState(false);

  // Reset flip state when flashcard changes
  useEffect(() => {
    setIsFlipped(false);
  }, [flashcard.id]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.code === 'Space') {
        event.preventDefault();
        setIsFlipped(!isFlipped);
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [isFlipped]);

  const handleFlip = () => {
    setIsFlipped(!isFlipped);
  };

  return (
    <div className="w-full max-w-2xl mx-auto">
      <Card className="min-h-[300px] md:min-h-[350px] cursor-pointer transition-all duration-500 hover:shadow-lg transform hover:scale-[1.02] bg-gradient-to-br from-white to-gray-50">
        <CardContent className="p-6 md:p-8 flex flex-col items-center justify-center text-center space-y-6 min-h-[300px] md:min-h-[350px]">
          <div className="flex-1 flex items-center justify-center w-full">
            <div className="transition-all duration-300 ease-in-out">
              <p className="text-lg md:text-xl leading-relaxed break-words max-w-full">
                {isFlipped ? flashcard.back : flashcard.front}
              </p>
            </div>
          </div>
          
          <div className="space-y-3 w-full">
            <Button 
              onClick={handleFlip}
              variant="outline"
              className="min-w-[140px] transition-all duration-200 hover:scale-105"
              size="lg"
            >
              {isFlipped ? 'Pokaż przód' : 'Pokaż tył'}
            </Button>
            
            <div className="space-y-1">
              <p className="text-xs text-muted-foreground">
                {isFlipped ? 'Tył karty' : 'Przód karty'}
              </p>
              <p className="text-xs text-muted-foreground">
                Naciśnij <kbd className="px-1 py-0.5 bg-gray-100 rounded text-xs">Spacja</kbd> aby odwrócić
              </p>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}


================================================
FILE: src/components/ui/StudyProgress.tsx
================================================
interface StudyProgressProps {
  current: number;
  total: number;
}

export default function StudyProgress({ current, total }: StudyProgressProps) {
  const percentage = (current / total) * 100;

  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between text-sm text-muted-foreground">
        <span>Postęp</span>
        <span>{current}/{total}</span>
      </div>
      
      <div className="w-full bg-secondary rounded-full h-2">
        <div 
          className="bg-primary h-2 rounded-full transition-all duration-300" 
          style={{ width: `${percentage}%` }}
        />
      </div>
      
      <div className="text-center text-xs text-muted-foreground">
        {Math.round(percentage)}% ukończone
      </div>
    </div>
  );
}


================================================
FILE: src/components/ui/textarea.tsx
================================================
import * as React from "react"

import { cn } from "../../lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }



================================================
FILE: src/components/views/DashboardView.tsx
================================================
import React from 'react';
import { useDashboardState } from '../hooks/useDashboardState';
import { Button } from '../ui/button';
import FolderGrid from './FolderGrid.tsx';
import EditFolderDialog from './EditFolderDialog.tsx';
import DeleteFolderDialog from './DeleteFolderDialog.tsx';

interface DashboardViewProps {
  userId: string;
}

/**
 * DashboardView - Main container for the dashboard page
 * Manages state, fetches data, and coordinates interactions between child components
 */
const DashboardView: React.FC<DashboardViewProps> = ({ userId }) => {
  const {
    folders,
    isLoading,
    error,
    editingFolder,
    deletingFolder,
    handleRefresh,
    handleEditFolder,
    handleDeleteFolder,
    handleCloseEditDialog,
    handleCloseDeleteDialog,
    handleSaveFolder,
    handleConfirmDelete,
  } = useDashboardState(userId);

  return (
    <div className="container mx-auto px-4 py-8 max-w-7xl">
      {/* Header */}
      <header className="mb-8">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
          <h1 className="text-3xl font-bold text-gray-900">Twoje foldery</h1>
          
          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row gap-3">
            <a href="/generate">
              <Button 
                size="lg"
                className="w-full sm:w-auto"
              >
                Generuj fiszki
              </Button>
            </a>
            <a href="/manual-save">
              <Button 
                size="lg"
                variant="outline" 
                className="w-full sm:w-auto">
                Dodaj fiszkę
              </Button>
            </a>
          </div>
        </div>
      </header>

      {/* Main Content */}
      <main>
        {error ? (
          /* Error State */
          <div className="text-center py-12">
            <div className="bg-red-50 border border-red-200 rounded-lg p-6 max-w-md mx-auto">
              <h2 className="text-lg font-semibold text-red-800 mb-2">
                Wystąpił błąd
              </h2>
              <p className="text-red-600 mb-4">{error}</p>
              <Button onClick={handleRefresh} variant="outline">
                Spróbuj ponownie
              </Button>
            </div>
          </div>
        ) : folders.length === 0 && !isLoading ? (
          /* Empty State */
          <div className="text-center py-12">
            <div className="max-w-md mx-auto">
              <h2 className="text-xl font-semibold text-gray-700 mb-2">
                Nie masz jeszcze żadnych folderów
              </h2>
              <p className="text-gray-500 mb-6">
                Rozpocznij od wygenerowania fiszek lub dodania pierwszej fiszki ręcznie.
              </p>
              <div className="flex flex-col sm:flex-row gap-3 justify-center">
                <a href="/generate">
                  <Button className="w-full sm:w-auto">
                    Generuj pierwsze fiszki
                  </Button>
                </a>
                <a href="/manual-save">
                  <Button variant="outline" className="w-full sm:w-auto">
                    Dodaj fiszkę ręcznie
                  </Button>
                </a>
              </div>
            </div>
          </div>
        ) : (
          /* Folder Grid */
          <FolderGrid
            folders={folders}
            isLoading={isLoading}
            onEdit={handleEditFolder}
            onDelete={handleDeleteFolder}
          />
        )}
      </main>

      {/* Edit Folder Dialog */}
      <EditFolderDialog
        isOpen={!!editingFolder}
        folder={editingFolder}
        onClose={handleCloseEditDialog}
        onSave={handleSaveFolder}
      />

      {/* Delete Folder Dialog */}
      <DeleteFolderDialog
        isOpen={!!deletingFolder}
        folder={deletingFolder}
        onClose={handleCloseDeleteDialog}
        onConfirm={handleConfirmDelete}
      />
    </div>
  );
};

export default DashboardView;


================================================
FILE: src/components/views/DeleteFlashcardDialog.tsx
================================================
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import type { FlashcardViewModel } from '../../types';

interface DeleteFlashcardDialogProps {
  isOpen: boolean;
  flashcard: FlashcardViewModel | null;
  onClose: () => void;
  onConfirm: (flashcardId: string) => void;
}

const DeleteFlashcardDialog: React.FC<DeleteFlashcardDialogProps> = ({
  isOpen,
  flashcard,
  onClose,
  onConfirm,
}) => {
  const [isDeleting, setIsDeleting] = useState(false);

  const handleConfirm = async () => {
    if (!flashcard) return;

    setIsDeleting(true);
    try {
      await onConfirm(flashcard.id);
      onClose();
    } catch (error) {
      console.error('Failed to delete flashcard:', error);
      // Error handling is managed by the parent component
    } finally {
      setIsDeleting(false);
    }
  };

  const handleClose = () => {
    if (!isDeleting) {
      onClose();
    }
  };

  // Truncate text for preview if too long
  const truncateText = (text: string, maxLength: number = 50) => {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2 text-red-600">
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                strokeWidth={2} 
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z" 
              />
            </svg>
            Delete Flashcard
          </DialogTitle>
          <DialogDescription asChild>
            <div className="space-y-3">
              <p>Are you sure you want to delete this flashcard? This action cannot be undone.</p>
              
              {flashcard && (
                <div className="bg-gray-50 border border-gray-200 rounded-lg p-4 space-y-3">
                  <div>
                    <span className="text-sm font-medium text-gray-700">Front:</span>
                    <p className="text-sm text-gray-900 mt-1">
                      {truncateText(flashcard.front)}
                    </p>
                  </div>
                  <div>
                    <span className="text-sm font-medium text-gray-700">Back:</span>
                    <p className="text-sm text-gray-900 mt-1">
                      {truncateText(flashcard.back)}
                    </p>
                  </div>
                  <div className="flex items-center gap-2">
                    <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-700">
                      {flashcard.generation_source === 'ai' ? (
                        <>
                          <svg className="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                          </svg>
                          AI Generated
                        </>
                      ) : (
                        <>
                          <svg className="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
                          </svg>
                          Manual
                        </>
                      )}
                    </span>
                    <span className="text-xs text-gray-500">
                      Created {new Date(flashcard.created_at).toLocaleDateString()}
                    </span>
                  </div>
                </div>
              )}
            </div>
          </DialogDescription>
        </DialogHeader>

        <DialogFooter className="gap-2">
          <Button
            type="button"
            variant="outline"
            onClick={handleClose}
            disabled={isDeleting}
          >
            Cancel
          </Button>
          <Button
            type="button"
            variant="destructive"
            onClick={handleConfirm}
            disabled={isDeleting}
            className="min-w-[100px]"
          >
            {isDeleting ? (
              <>
                <svg className="animate-spin -ml-1 mr-2 h-4 w-4" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                </svg>
                Deleting...
              </>
            ) : (
              <>
                <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
                Delete Flashcard
              </>
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default DeleteFlashcardDialog;


================================================
FILE: src/components/views/DeleteFolderDialog.tsx
================================================
import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '../ui/dialog';
import { Button } from '../ui/button';
import { AlertTriangle } from 'lucide-react';
import type { FolderViewModel } from '../../types';

interface DeleteFolderDialogProps {
  isOpen: boolean;
  folder: FolderViewModel | null;
  onClose: () => void;
  onConfirm: (folderId: string) => Promise<void>;
}

/**
 * DeleteFolderDialog - Modal with confirmation request for folder deletion
 */
const DeleteFolderDialog: React.FC<DeleteFolderDialogProps> = ({
  isOpen,
  folder,
  onClose,
  onConfirm,
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Reset error when dialog opens/closes
  useEffect(() => {
    if (isOpen) {
      setError(null);
    }
  }, [isOpen]);

  const handleConfirm = async () => {
    if (!folder) return;

    setIsLoading(true);
    setError(null);

    try {
      await onConfirm(folder.id);
      // Dialog will be closed by parent component after successful deletion
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Nie udało się usunąć folderu. Spróbuj ponownie.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleClose = () => {
    if (!isLoading) {
      onClose();
    }
  };

  const flashcardText = folder?.flashcard_count === 1 ? 'fiszkę' : 'fiszek';

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <AlertTriangle className="h-5 w-5 text-red-600" />
            Usuń folder
          </DialogTitle>
          <DialogDescription>
            Ta akcja jest nieodwracalna. Zostanie usunięty folder i wszystkie fiszki w nim zawarte.
          </DialogDescription>
        </DialogHeader>
        
        <div className="py-4">
          <div className="bg-red-50 border border-red-200 rounded-lg p-4">
            <h3 className="font-semibold text-red-800 mb-2">
              Folder do usunięcia:
            </h3>
            <p className="text-red-700 mb-1">
              <strong>"{folder?.name}"</strong>
            </p>
            <p className="text-red-600 text-sm">
              Zawiera {folder?.flashcard_count || 0} {flashcardText}
            </p>
          </div>
          
          <p className="text-gray-600 text-sm mt-4">
            Czy na pewno chcesz usunąć ten folder? Wszystkie fiszki w nim zawarte zostaną trwale utracone.
          </p>
        </div>

        {/* Error message from API */}
        {error && (
          <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md">
            <p className="text-sm text-red-600">{error}</p>
          </div>
        )}

        <DialogFooter>
          <Button
            type="button"
            variant="outline"
            onClick={handleClose}
            disabled={isLoading}
          >
            Anuluj
          </Button>
          <Button
            type="button"
            variant="destructive"
            onClick={handleConfirm}
            disabled={isLoading}
          >
            {isLoading ? 'Usuwanie...' : 'Usuń folder'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default DeleteFolderDialog;


================================================
FILE: src/components/views/EditFlashcardDialog.tsx
================================================
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import CharacterCounter from '@/components/ui/CharacterCounter';
import type { FlashcardViewModel, UpdateFlashcardCommand } from '../../types';

interface EditFlashcardDialogProps {
  isOpen: boolean;
  flashcard: FlashcardViewModel | null;
  onClose: () => void;
  onSave: (flashcardId: string, command: UpdateFlashcardCommand) => void;
}

interface FormData {
  front: string;
  back: string;
}

interface FormErrors {
  front?: string;
  back?: string;
}

const EditFlashcardDialog: React.FC<EditFlashcardDialogProps> = ({
  isOpen,
  flashcard,
  onClose,
  onSave,
}) => {
  const [formData, setFormData] = useState<FormData>({
    front: '',
    back: '',
  });
  
  const [errors, setErrors] = useState<FormErrors>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Constants for validation
  const FRONT_MAX_LENGTH = 200;
  const BACK_MAX_LENGTH = 500;

  // Reset form when flashcard changes
  useEffect(() => {
    if (flashcard) {
      setFormData({
        front: flashcard.front,
        back: flashcard.back,
      });
      setErrors({});
    } else {
      setFormData({
        front: '',
        back: '',
      });
      setErrors({});
    }
  }, [flashcard]);

  // Real-time validation
  const validateField = (field: keyof FormData, value: string): string | undefined => {
    switch (field) {
      case 'front':
        if (!value.trim()) {
          return 'Przód fiszki jest wymagany';
        }
        if (value.length > FRONT_MAX_LENGTH) {
          return `Przednia strona musi mieć ${FRONT_MAX_LENGTH} znaków lub mniej`;
        }
        break;
      case 'back':
        if (!value.trim()) {
          return 'Tył fiszki jest wymagany';
        }
        if (value.length > BACK_MAX_LENGTH) {
          return `Tył musi mieć ${BACK_MAX_LENGTH} znaków lub mniej`;
        }
        break;
    }
    return undefined;
  };

  // Handle input changes with validation
  const handleInputChange = (field: keyof FormData, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    
    // Clear error for this field if it becomes valid
    const error = validateField(field, value);
    setErrors(prev => ({ ...prev, [field]: error }));
  };

  // Validate entire form
  const validateForm = (): boolean => {
    const newErrors: FormErrors = {};
    
    newErrors.front = validateField('front', formData.front);
    newErrors.back = validateField('back', formData.back);

    setErrors(newErrors);
    return !Object.values(newErrors).some(error => error);
  };

  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!flashcard || !validateForm()) {
      return;
    }

    setIsSubmitting(true);
    
    try {
      const command: UpdateFlashcardCommand = {
        front: formData.front.trim(),
        back: formData.back.trim(),
        generation_source: flashcard.generation_source,
      };

      await onSave(flashcard.id, command);
      onClose();
    } catch (error) {
      console.error('Failed to update flashcard:', error);
      // Error handling is managed by the parent component
    } finally {
      setIsSubmitting(false);
    }
  };

  // Handle dialog close
  const handleClose = () => {
    if (!isSubmitting) {
      onClose();
    }
  };

  // Check if form has changes
  const hasChanges = flashcard && (
    formData.front.trim() !== flashcard.front ||
    formData.back.trim() !== flashcard.back
  );

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-[600px]">
        <DialogHeader>
          <DialogTitle>Edytuj fiszkę</DialogTitle>
          <DialogDescription>
            Zmodyfikuj swoją fiszkę. Kliknij zapisz, gdy skończysz.
          </DialogDescription>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-6">
          {/* Front Side */}
          <div className="space-y-2">
            <Label htmlFor="front">
              Przód fiszki <span className="text-red-500">*</span>
            </Label>
            <Input
              id="front"
              value={formData.front}
              onChange={(e) => handleInputChange('front', e.target.value)}
              placeholder="Dodaj przód fiszki"
              className={errors.front ? 'border-red-500 focus:border-red-500' : ''}
              disabled={isSubmitting}
              maxLength={FRONT_MAX_LENGTH} 
            />
            <div className="flex justify-between items-center">
              {errors.front && (
                <span className="text-sm text-red-600">{errors.front}</span>
              )}
              <div className="ml-auto">
                <CharacterCounter
                  currentLength={formData.front.length}
                  maxLength={FRONT_MAX_LENGTH}
                />
              </div>
            </div>
          </div>

          {/* Back Side */}
          <div className="space-y-2">
            <Label htmlFor="back">
              Tył Fiszki <span className="text-red-500">*</span>
            </Label>
            <Textarea
              id="back"
              value={formData.back}
              onChange={(e) => handleInputChange('back', e.target.value)}
              placeholder="Dodaj tył fiszki"
              className={errors.back ? 'border-red-500 focus:border-red-500' : ''}
              disabled={isSubmitting}
              rows={4}
              maxLength={BACK_MAX_LENGTH} 
            />
            <div className="flex justify-between items-center">
              {errors.back && (
                <span className="text-sm text-red-600">{errors.back}</span>
              )}
              <div className="ml-auto">
                <CharacterCounter
                  currentLength={formData.back.length}
                  maxLength={BACK_MAX_LENGTH}
                />
              </div>
            </div>
          </div>

          {/* Source Info */}
          {flashcard && (
            <div className="text-sm text-gray-600 bg-gray-50 p-3 rounded-lg">
              <span className="font-medium">Źródło:</span>{' '}
              {flashcard.generation_source === 'ai' ? 'AI Generated' : 'Manual'}
            </div>
          )}

          <DialogFooter className="gap-2">
            <Button
              type="button"
              variant="outline"
              onClick={handleClose}
              disabled={isSubmitting}
            >
              Cancel
            </Button>
            <Button
              type="submit"
              disabled={isSubmitting || !hasChanges || Object.values(errors).some(error => error)}
              className="min-w-[80px]"
            >
              {isSubmitting ? (
                <>
                  <svg className="animate-spin -ml-1 mr-2 h-4 w-4" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                  </svg>
                  Zapisywanie...
                </>
              ) : (
                'Zapisz zmiany'
              )}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};

export default EditFlashcardDialog;


================================================
FILE: src/components/views/EditFolderDialog.tsx
================================================
import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '../ui/dialog';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Label } from '../ui/label';
import type { FolderViewModel } from '../../types';

interface EditFolderDialogProps {
  isOpen: boolean;
  folder: FolderViewModel | null;
  onClose: () => void;
  onSave: (folderId: string, newName: string) => Promise<void>;
}

/**
 * EditFolderDialog - Modal with form for editing existing folder name
 */
const EditFolderDialog: React.FC<EditFolderDialogProps> = ({
  isOpen,
  folder,
  onClose,
  onSave,
}) => {
  const [name, setName] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Reset form when dialog opens/closes or folder changes
  useEffect(() => {
    if (isOpen && folder) {
      setName(folder.name);
      setError(null);
    } else {
      setName('');
      setError(null);
    }
  }, [isOpen, folder]);

  // Validation logic
  const trimmedName = name.trim();
  const isNameEmpty = trimmedName.length === 0;
  const isNameTooLong = trimmedName.length > 100;
  const isNameUnchanged = folder && trimmedName === folder.name;
  const isFormValid = !isNameEmpty && !isNameTooLong && !isNameUnchanged;

  const getValidationMessage = (): string | null => {
    if (isNameEmpty) return 'Nazwa folderu jest wymagana';
    if (isNameTooLong) return 'Nazwa folderu nie może przekraczać 100 znaków';
    if (isNameUnchanged) return 'Wprowadź nową nazwę dla folderu';
    return null;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!folder || !isFormValid) return;

    setIsLoading(true);
    setError(null);

    try {
      await onSave(folder.id, trimmedName);
      // Dialog will be closed by parent component after successful save
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Nie udało się zapisać zmian. Spróbuj ponownie.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleClose = () => {
    if (!isLoading) {
      onClose();
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Edytuj folder</DialogTitle>
          <DialogDescription>
            Zmień nazwę folderu "{folder?.name}". Zmiany zostaną zapisane automatycznie.
          </DialogDescription>
        </DialogHeader>
        
        <form onSubmit={handleSubmit}>
          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label htmlFor="folder-name">Nazwa folderu</Label>
              <Input
                id="folder-name"
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                disabled={isLoading}
                placeholder="Wprowadź nazwę folderu"
                maxLength={100}
                autoFocus
              />
              {/* Character counter */}
              <div className="text-xs text-gray-500 text-right">
                {trimmedName.length}/100 znaków
              </div>
              
              {/* Validation message */}
              {getValidationMessage() && (
                <p className="text-sm text-red-600">{getValidationMessage()}</p>
              )}
            </div>
          </div>

          {/* Error message from API */}
          {error && (
            <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md">
              <p className="text-sm text-red-600">{error}</p>
            </div>
          )}

          <DialogFooter>
            <Button
              type="button"
              variant="outline"
              onClick={handleClose}
              disabled={isLoading}
            >
              Anuluj
            </Button>
            <Button
              type="submit"
              disabled={!isFormValid || isLoading}
            >
              {isLoading ? 'Zapisywanie...' : 'Zapisz zmiany'}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};

export default EditFolderDialog;


================================================
FILE: src/components/views/FlashcardGeneratorForm.tsx
================================================
import React, { useState, useCallback } from 'react';
import { Button } from '@/components/ui/button';

interface FlashcardGeneratorFormProps {
  onGenerate: (text: string) => void;
  isLoading: boolean;
  initialText?: string;
  onTextChange?: (text: string) => void;
}

const FlashcardGeneratorForm: React.FC<FlashcardGeneratorFormProps> = ({
  onGenerate,
  isLoading,
  initialText = '',
  onTextChange,
}) => {
  const [text, setText] = useState<string>(initialText);

  // Character limits
  const MIN_CHARS = 1;
  const MAX_CHARS = 5000;

  // Validation
  const isTextValid = text.trim().length >= MIN_CHARS && text.length <= MAX_CHARS;
  const isSubmitDisabled = !isTextValid || isLoading;

  // Handle text change
  const handleTextChange = useCallback((event: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newText = event.target.value;
    setText(newText);
    onTextChange?.(newText);
  }, [onTextChange]);

  // Handle form submission
  const handleSubmit = useCallback((event: React.FormEvent) => {
    event.preventDefault();
    
    if (!isTextValid || isLoading) {
      return;
    }

    onGenerate(text.trim());
  }, [text, isTextValid, isLoading, onGenerate]);

  // Get character count styling
  const getCharCountClassName = () => {
    if (text.length > MAX_CHARS) {
      return 'text-red-600';
    }
    if (text.length > MAX_CHARS * 0.9) {
      return 'text-amber-600';
    }
    return 'text-gray-500';
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="space-y-2">
        <label 
          htmlFor="text-input" 
          className="block text-sm font-medium text-gray-700"
        >
          Tekst do analizy
        </label>
        <div className="relative">
          <textarea
            id="text-input"
            value={text}
            onChange={handleTextChange}
            placeholder="Wklej tutaj tekst z którego AI ma wygenerować fiszki do nauki..."
            className="w-full min-h-[200px] p-4 border border-gray-300 rounded-lg resize-y focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            disabled={isLoading}
            maxLength={MAX_CHARS + 100} // Allow slight overflow for better UX
          />
        </div>
        
        {/* Character counter */}
        <div className="flex justify-between items-center text-sm">
          <div className="text-gray-600">
            Minimum {MIN_CHARS} znaków
          </div>
          <div className={getCharCountClassName()}>
            {text.length} / {MAX_CHARS}
          </div>
        </div>

        {/* Validation message */}
        {text.length > MAX_CHARS && (
          <p className="text-sm text-red-600">
            Tekst jest za długi. Maksymalna długość to {MAX_CHARS} znaków.
          </p>
        )}
        
        {text.trim().length > 0 && text.trim().length < MIN_CHARS && (
          <p className="text-sm text-red-600">
            Tekst jest za krótki. Minimalna długość to {MIN_CHARS} znak.
          </p>
        )}
      </div>

      <div className="flex justify-center">
        <Button
          size="lg"
          type="submit"
          disabled={isSubmitDisabled}
          className="px-8 py-2 text-md"
        >
          {isLoading ? 'Generuję...' : 'Generuj fiszki'}
        </Button>
      </div>

      {/* Tips for better results */}
      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <h4 className="text-sm font-medium text-blue-900 mb-2">
          Wskazówki dla lepszych rezultatów:
        </h4>
        <ul className="text-sm text-blue-800 space-y-1">
          <li>• Używaj tekstu edukacyjnego z jasno zdefiniowanymi pojęciami</li>
          <li>• Unikaj zbyt ogólnych lub zbyt technicznych fragmentów</li>
          <li>• Dłuższe teksty pozwalają na wygenerowanie więcej różnorodnych fiszek</li>
          <li>• Strukturyzowane treści (z nagłówkami, punktami) działają najlepiej</li>
        </ul>
      </div>
    </form>
  );
};

export default FlashcardGeneratorForm;


================================================
FILE: src/components/views/FlashcardList.tsx
================================================
import React from 'react';
import { Button } from '@/components/ui/button';
import FlashcardListItem from './FlashcardListItem';
import LoadingSpinner from './LoadingSpinner';
import type { FlashcardViewModel, Pagination } from '../../types';

interface FlashcardListProps {
  flashcards: FlashcardViewModel[];
  pagination: Pagination | null;
  isLoading: boolean;
  onPageChange: (page: number) => void;
  onEdit: (flashcard: FlashcardViewModel) => void;
  onDelete: (flashcard: FlashcardViewModel) => void;
}

const PaginationControls: React.FC<{
  pagination: Pagination;
  onPageChange: (page: number) => void;
}> = ({ pagination, onPageChange }) => {
  if (pagination.totalPages <= 1) return null;

  const { page, totalPages } = pagination;
  
  // Generate page numbers to show
  const getVisiblePages = () => {
    const delta = 2;
    const range = [];
    const rangeWithDots = [];

    for (let i = Math.max(2, page - delta); i <= Math.min(totalPages - 1, page + delta); i++) {
      range.push(i);
    }

    if (page - delta > 2) {
      rangeWithDots.push(1, '...');
    } else {
      rangeWithDots.push(1);
    }

    rangeWithDots.push(...range);

    if (page + delta < totalPages - 1) {
      rangeWithDots.push('...', totalPages);
    } else {
      rangeWithDots.push(totalPages);
    }

    return rangeWithDots;
  };

  return (
    <div className="flex items-center justify-center space-x-2 mt-8">
      {/* Previous Button */}
      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(page - 1)}
        disabled={page <= 1}
        className="px-3 py-2"
      >
        <svg className="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
        </svg>
        Previous
      </Button>

      {/* Page Numbers */}
      <div className="flex items-center space-x-1">
        {getVisiblePages().map((pageNum, index) => (
          <React.Fragment key={index}>
            {pageNum === '...' ? (
              <span className="px-3 py-2 text-gray-500">...</span>
            ) : (
              <Button
                variant={pageNum === page ? "default" : "outline"}
                size="sm"
                onClick={() => onPageChange(pageNum as number)}
                className="px-3 py-2 min-w-[40px]"
              >
                {pageNum}
              </Button>
            )}
          </React.Fragment>
        ))}
      </div>

      {/* Next Button */}
      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(page + 1)}
        disabled={page >= totalPages}
        className="px-3 py-2"
      >
        Next
        <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
        </svg>
      </Button>
    </div>
  );
};

const FlashcardList: React.FC<FlashcardListProps> = ({
  flashcards,
  pagination,
  isLoading,
  onPageChange,
  onEdit,
  onDelete,
}) => {
  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-12">
        <LoadingSpinner />
      </div>
    );
  }

  if (flashcards.length === 0) {
    return (
      <div className="text-center py-12">
        <div className="mx-auto w-24 h-24 mb-4 text-gray-300">
          <svg fill="currentColor" viewBox="0 0 24 24">
            <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z" />
          </svg>
        </div>
        <h3 className="text-lg font-medium text-gray-900 mb-2">Brak fiszek</h3>
        <p className="text-gray-600 text-base mb-4">Ten folder jest pusty.</p>
        <p className="text-gray-500 text-sm">Dodaj nowe fiszki i zacznij naukę!</p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Flashcards Grid */}
      <div className="space-y-4">
        {flashcards.map((flashcard) => (
          <FlashcardListItem
            key={flashcard.id}
            flashcard={flashcard}
            onEdit={onEdit}
            onDelete={onDelete}
          />
        ))}
      </div>

      {/* Results Info */}
      {pagination && (
        <div className="flex items-center justify-between text-sm text-gray-600 mt-6">
          <div>
            Widok od {Math.min((pagination.page - 1) * pagination.limit + 1, pagination.total)} do {' '}
            {Math.min(pagination.page * pagination.limit, pagination.total)} z {pagination.total} fiszek w folderze
          </div>
          <div>
            Strona {pagination.page} z {pagination.totalPages}
          </div>
        </div>
      )}

      {/* Pagination Controls */}
      {pagination && (
        <PaginationControls
          pagination={pagination}
          onPageChange={onPageChange}
        />
      )}
    </div>
  );
};

export default FlashcardList;


================================================
FILE: src/components/views/FlashcardListItem.tsx
================================================
import React from 'react';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Card, CardContent } from '@/components/ui/card';
import type { FlashcardViewModel } from '../../types';

interface FlashcardListItemProps {
  flashcard: FlashcardViewModel;
  onEdit: (flashcard: FlashcardViewModel) => void;
  onDelete: (flashcard: FlashcardViewModel) => void;
}

const FlashcardListItem: React.FC<FlashcardListItemProps> = ({
  flashcard,
  onEdit,
  onDelete,
}) => {
  return (
    <Card className="w-full">
      <CardContent className="p-4">
        <div className="flex justify-between items-start">
          <div className="flex-1 min-w-0">
            {/* Front Side */}
            <div className="mb-3">
              <h3 className="font-semibold text-gray-900 mb-1 text-sm uppercase tracking-wide">
                Front:
              </h3>
              <p className="text-gray-700 break-words">{flashcard.front}</p>
            </div>

            {/* Back Side */}
            <div className="mb-3">
              <h3 className="font-semibold text-gray-900 mb-1 text-sm uppercase tracking-wide">
                Back:
              </h3>
              <p className="text-gray-700 break-words">{flashcard.back}</p>
            </div>

            {/* Origin Badge */}
            <div className="flex items-center justify-between">
              <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-700">
                {flashcard.generation_source === 'ai' ? (
                  <>
                    <svg className="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                      <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    AI Generated
                  </>
                ) : (
                  <>
                    <svg className="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                      <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
                    </svg>
                    Manual
                  </>
                )}
              </span>
              
              <div className="text-xs text-gray-500">
                Updated {new Date(flashcard.updated_at).toLocaleDateString()}
              </div>
            </div>
          </div>

          {/* Actions Dropdown */}
          <div className="ml-4 flex-shrink-0">
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                  <span className="sr-only">Open menu</span>
                  <svg
                    className="h-4 w-4"
                    fill="currentColor"
                    viewBox="0 0 20 20"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z" />
                  </svg>
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end" className="w-48">
                <DropdownMenuItem
                  onClick={() => onEdit(flashcard)}
                  className="cursor-pointer"
                >
                  <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                  </svg>
                  Edytuj fiszkę
                </DropdownMenuItem>
                <DropdownMenuItem
                  onClick={() => onDelete(flashcard)}
                  className="cursor-pointer text-red-600 focus:text-red-600"
                >
                  <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                  </svg>
                    Usuń fiszkę
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default FlashcardListItem;


================================================
FILE: src/components/views/FlashcardProposalCard.tsx
================================================
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import type { FlashcardProposalViewModel } from '@/types';

interface FlashcardProposalCardProps {
  proposal: FlashcardProposalViewModel;
  onUpdate: (updatedProposal: FlashcardProposalViewModel) => void;
  disabled?: boolean;
}

const FlashcardProposalCard: React.FC<FlashcardProposalCardProps> = ({
  proposal,
  onUpdate,
  disabled = false,
}) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editForm, setEditForm] = useState({
    front: proposal.front,
    back: proposal.back,
  });

  // Handle status changes
  const handleAccept = () => {
    onUpdate({ ...proposal, status: 'accepted' });
  };

  const handleReject = () => {
    onUpdate({ ...proposal, status: 'rejected' });
  };

  const handleEdit = () => {
    setIsEditing(true);
    setEditForm({
      front: proposal.front,
      back: proposal.back,
    });
  };

  // Handle edit form changes
  const handleEditFormChange = (field: 'front' | 'back', value: string) => {
    setEditForm(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  // Handle save edit
  const handleSaveEdit = () => {
    // Validation
    const trimmedFront = editForm.front.trim();
    const trimmedBack = editForm.back.trim();

    if (trimmedFront.length === 0 || trimmedBack.length === 0) {
      return; // Don't save if empty
    }

    onUpdate({
      ...proposal,
      front: trimmedFront,
      back: trimmedBack,
    });

    setIsEditing(false);
  };

  // Handle cancel edit
  const handleCancelEdit = () => {
    setIsEditing(false);
    setEditForm({
      front: proposal.front,
      back: proposal.back,
    });
  };

  // Get card styling based on status
  const getCardClassName = () => {
    const baseClasses = "transition-all duration-200";
    
    switch (proposal.status) {
      case 'accepted':
        return `${baseClasses} border-green-200 bg-green-50`;
      case 'rejected':
        return `${baseClasses} border-red-200 bg-red-50 opacity-75`;
      default:
        return `${baseClasses} border-gray-200 hover:border-gray-300`;
    }
  };

  // Validation for edit form
  const isEditFormValid = editForm.front.trim().length > 0 && 
    editForm.front.length <= 200 && 
    editForm.back.trim().length > 0 && 
    editForm.back.length <= 500;

  return (
    <Card className={getCardClassName()}>
      <CardHeader className="pb-3">
        <div className="flex items-center justify-between">
          {/* Status indicator */}
          <div className="flex items-center space-x-2">
            <div className={`w-3 h-3 rounded-full ${
              proposal.status === 'accepted' ? 'bg-green-500' :
              proposal.status === 'rejected' ? 'bg-red-500' :
              'bg-gray-300'
            }`} />
            <span className="text-sm font-medium capitalize text-gray-700">
              {proposal.status === 'pending' && 'Oczekuje'}
              {proposal.status === 'accepted' && 'Zaakceptowana'}
              {proposal.status === 'rejected' && 'Odrzucona'}
            </span>
          </div>

          {/* Action buttons */}
          {!isEditing && (
            <div className="flex space-x-2">
              {proposal.status !== 'accepted' && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleAccept}
                  disabled={disabled}
                  className="text-green-600 border-green-300 hover:bg-green-50"
                >
                  Akceptuj
                </Button>
              )}
              
              {proposal.status !== 'rejected' && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleReject}
                  disabled={disabled}
                  className="text-red-600 border-red-300 hover:bg-red-50"
                >
                  Odrzuć
                </Button>
              )}

              <Button
                variant="outline"
                size="sm"
                onClick={handleEdit}
                disabled={disabled}
              >
                Edytuj
              </Button>
            </div>
          )}

          {/* Edit action buttons */}
          {isEditing && (
            <div className="flex space-x-2">
              <Button
                variant="outline"
                size="sm"
                onClick={handleSaveEdit}
                disabled={!isEditFormValid}
                className="text-green-600 border-green-300 hover:bg-green-50"
              >
                Zapisz
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={handleCancelEdit}
              >
                Anuluj
              </Button>
            </div>
          )}
        </div>
      </CardHeader>

      <CardContent className="space-y-4">
        {!isEditing ? (
          // Display mode
          <>
            <div>
              <h4 className="text-sm font-medium text-gray-700 mb-1">Przód fiszki:</h4>
              <p className="text-gray-900 bg-white p-3 rounded border">
                {proposal.front}
              </p>
            </div>

            <div>
              <h4 className="text-sm font-medium text-gray-700 mb-1">Tył fiszki:</h4>
              <p className="text-gray-900 bg-white p-3 rounded border">
                {proposal.back}
              </p>
            </div>
          </>
        ) : (
          // Edit mode
          <>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Przód fiszki:
              </label>
              <textarea
                value={editForm.front}
                onChange={(e) => handleEditFormChange('front', e.target.value)}
                className="w-full p-3 border border-gray-300 rounded-md resize-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                rows={2}
                maxLength={200}
                placeholder="Pytanie lub pojęcie..."
              />
              <div className="text-xs text-gray-500 mt-1">
                {editForm.front.length} / 200 znaków
              </div>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Tył fiszki:
              </label>
              <textarea
                value={editForm.back}
                onChange={(e) => handleEditFormChange('back', e.target.value)}
                className="w-full p-3 border border-gray-300 rounded-md resize-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                rows={3}
                maxLength={500}
                placeholder="Odpowiedź lub wyjaśnienie..."
              />
              <div className="text-xs text-gray-500 mt-1">
                {editForm.back.length} / 500 znaków
              </div>
            </div>

            {/* Validation messages */}
            {editForm.front.trim().length === 0 && (
              <p className="text-xs text-red-600">Przód fiszki nie może być pusty</p>
            )}
            {editForm.back.trim().length === 0 && (
              <p className="text-xs text-red-600">Tył fiszki nie może być pusty</p>
            )}
          </>
        )}
      </CardContent>
    </Card>
  );
};

export default FlashcardProposalCard;


================================================
FILE: src/components/views/FlashcardProposalList.tsx
================================================
import React, { useState, useMemo } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import type { Folder, FlashcardProposalViewModel } from '@/types';
import FlashcardProposalCard from './FlashcardProposalCard';
import FolderSelect from './FolderSelect';

interface FlashcardProposalListProps {
  proposals: FlashcardProposalViewModel[];
  suggestedFolderName: string;
  folders: Folder[];
  onUpdateProposal: (updatedProposal: FlashcardProposalViewModel) => void;
  onSave: (folderId: string, folderName: string, acceptedFlashcards: FlashcardProposalViewModel[]) => void;
  onStartOver: () => void;
  isLoading: boolean;
}

const FlashcardProposalList: React.FC<FlashcardProposalListProps> = ({
  proposals,
  suggestedFolderName,
  folders,
  onUpdateProposal,
  onSave,
  onStartOver,
  isLoading,
}) => {
  const [selectedFolderId, setSelectedFolderId] = useState<string>('');
  const [customFolderName, setCustomFolderName] = useState<string>(suggestedFolderName);

  // Calculate accepted proposals
  const acceptedProposals = useMemo(() => {
    return proposals.filter(proposal => proposal.status === 'accepted');
  }, [proposals]);

  // Calculate proposal counts
  const proposalCounts = useMemo(() => {
    return {
      total: proposals.length,
      accepted: acceptedProposals.length,
      rejected: proposals.filter(p => p.status === 'rejected').length,
      pending: proposals.filter(p => p.status === 'pending').length,
    };
  }, [proposals, acceptedProposals]);

  // Handle bulk actions
  const handleAcceptAll = () => {
    proposals.forEach(proposal => {
      if (proposal.status === 'pending') {
        onUpdateProposal({ ...proposal, status: 'accepted' });
      }
    });
  };

  const handleRejectAll = () => {
    proposals.forEach(proposal => {
      if (proposal.status === 'pending') {
        onUpdateProposal({ ...proposal, status: 'rejected' });
      }
    });
  };

  // Handle save
  const handleSave = () => {
    if (acceptedProposals.length === 0) return;

    const folderName = selectedFolderId ? '' : customFolderName.trim();
    const folderId = selectedFolderId || 'new';
    
    onSave(folderId, folderName, acceptedProposals);
  };

  // Validation
  const isSaveDisabled = acceptedProposals.length === 0 || 
    isLoading || 
    (!selectedFolderId && customFolderName.trim().length === 0);

  return (
    <div className="space-y-6">
      {/* Header with stats and bulk actions */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            <span>Wygenerowane propozycje fiszek</span>
            <Button
              variant="outline"
              size="sm"
              onClick={onStartOver}
              disabled={isLoading}
            >
              Zacznij od nowa
            </Button>
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* Statistics */}
          <div className="flex flex-wrap gap-4 text-sm">
            <div className="flex items-center space-x-2">
              <div className="w-3 h-3 bg-gray-300 rounded-full"></div>
              <span>Oczekujące: {proposalCounts.pending}</span>
            </div>
            <div className="flex items-center space-x-2">
              <div className="w-3 h-3 bg-green-500 rounded-full"></div>
              <span>Zaakceptowane: {proposalCounts.accepted}</span>
            </div>
            <div className="flex items-center space-x-2">
              <div className="w-3 h-3 bg-red-500 rounded-full"></div>
              <span>Odrzucone: {proposalCounts.rejected}</span>
            </div>
          </div>

          {/* Bulk actions */}
          {proposalCounts.pending > 0 && (
            <div className="flex gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={handleAcceptAll}
                disabled={isLoading}
              >
                Zaakceptuj wszystkie oczekujące
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={handleRejectAll}
                disabled={isLoading}
              >
                Odrzuć wszystkie oczekujące
              </Button>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Proposals list */}
      <div className="space-y-4">
        {proposals.map((proposal) => (
          <FlashcardProposalCard
            key={proposal.id}
            proposal={proposal}
            onUpdate={onUpdateProposal}
            disabled={isLoading}
          />
        ))}
      </div>

      {/* Save section */}
      {acceptedProposals.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle>
              Zapisz {acceptedProposals.length} zaakceptowanych fiszek
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {/* Folder selection */}
            <FolderSelect
              folders={folders}
              selectedFolderId={selectedFolderId}
              customFolderName={customFolderName}
              suggestedFolderName={suggestedFolderName}
              onFolderSelect={setSelectedFolderId}
              onCustomFolderNameChange={setCustomFolderName}
              disabled={isLoading}
            />

            {/* Save button */}
            <div className="flex justify-center pt-4">
              <Button
                onClick={handleSave}
                disabled={isSaveDisabled}
                size="lg"
                className="px-8"
              >
                {isLoading 
                  ? 'Zapisuję...' 
                  : `Zapisz ${acceptedProposals.length} fiszek`
                }
              </Button>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Empty state for no accepted proposals */}
      {acceptedProposals.length === 0 && proposalCounts.total > 0 && (
        <Card>
          <CardContent className="py-8 text-center">
            <p className="text-gray-600 mb-4">
              Zaakceptuj przynajmniej jedną fiszkę, aby móc je zapisać.
            </p>
            <Button variant="outline" onClick={handleAcceptAll}>
              Zaakceptuj wszystkie
            </Button>
          </CardContent>
        </Card>
      )}
    </div>
  );
};

export default FlashcardProposalList;


================================================
FILE: src/components/views/FolderCard.tsx
================================================
import React from 'react';
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '../ui/card';
import { Button } from '../ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '../ui/dropdown-menu';
import { MoreVertical, FileText, Edit, Trash2, Eye } from 'lucide-react';
import type { FolderViewModel } from '../../types';

interface FolderCardProps {
  folder: FolderViewModel;
  onEdit: (folderId: string) => void;
  onDelete: (folderId: string) => void;
}

/**
 * FolderCard - Represents a single folder in the grid
 * Displays folder name, flashcard count, and action menu
 */
const FolderCard: React.FC<FolderCardProps> = ({
  folder,
  onEdit,
  onDelete,
}) => {
  const handleEdit = () => {
    onEdit(folder.id);
  };

  const handleDelete = () => {
    onDelete(folder.id);
  };

  return (
    <Card className="hover:shadow-md transition-shadow group">
      <CardHeader className="pb-3">
        <CardTitle className="text-lg font-semibold text-gray-900 truncate">
          {folder.name}
        </CardTitle>
      </CardHeader>
      
      <CardContent className="pb-4">
        <div className="flex items-center gap-2 text-sm text-gray-600">
          <FileText className="h-4 w-4" />
          <span>
            {folder.flashcard_count} {folder.flashcard_count === 1 ? 'fiszka' : 'fiszek'}
          </span>
        </div>
      </CardContent>
      
      <CardFooter className="pt-0 flex flex-col gap-2">
        <div className="flex justify-between w-full">
          <Button
            variant="outline"
            size="sm"
            className="text-blue-600 hover:text-blue-700"
            onClick={() => window.location.href = `/folders/${folder.id}`}
          >
            <Eye className="mr-2 h-4 w-4" />
            Podejrzyj folder
          </Button>
          
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                variant="ghost"
                className="h-8 w-8 p-0 opacity-0 group-hover:opacity-100 transition-opacity"
                aria-label={`Opcje dla folderu ${folder.name}`}
              >
                <MoreVertical className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-48">
              <DropdownMenuItem onClick={handleEdit} className="cursor-pointer">
                <Edit className="mr-2 h-4 w-4" />
                Edytuj nazwę
              </DropdownMenuItem>
              <DropdownMenuItem 
                onClick={handleDelete} 
                className="cursor-pointer text-red-600 focus:text-red-600"
              >
                <Trash2 className="mr-2 h-4 w-4" />
                Usuń folder
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
        
        {folder.flashcard_count >= 10 && (
          <Button
            className="w-full bg-green-600 hover:bg-green-700"
            size="sm"
            onClick={() => window.location.href = `/study/${folder.id}`}
          >
            Rozpocznij naukę
          </Button>
        )}
        
        {folder.flashcard_count > 0 && folder.flashcard_count < 10 && (
          <div className="w-full text-left">
            <p className="text-xs text-yellow-600">
              Potrzebujesz {10 - folder.flashcard_count} więcej {10 - folder.flashcard_count === 1 ? 'fiszki' : 'fiszek'} do nauki
            </p>
          </div>
        )}
      </CardFooter>
    </Card>
  );
};

export default FolderCard;


================================================
FILE: src/components/views/FolderCardSkeleton.tsx
================================================
import React from 'react';
import { Card, CardContent, CardFooter, CardHeader } from '../ui/card';
import { Skeleton } from '../ui/skeleton';

/**
 * FolderCardSkeleton - Skeleton component displayed during folder loading
 */
const FolderCardSkeleton: React.FC = () => {
  return (
    <Card className="hover:shadow-md transition-shadow">
      <CardHeader className="pb-3">
        <Skeleton className="h-6 w-3/4" />
      </CardHeader>
      <CardContent className="pb-4">
        <div className="flex items-center gap-2">
          <Skeleton className="h-4 w-4" />
          <Skeleton className="h-4 w-16" />
        </div>
      </CardContent>
      <CardFooter className="pt-0">
        <Skeleton className="h-8 w-8 ml-auto" />
      </CardFooter>
    </Card>
  );
};

export default FolderCardSkeleton;


================================================
FILE: src/components/views/FolderGrid.tsx
================================================
import React from 'react';
import type { FolderViewModel } from '../../types';
import FolderCard from './FolderCard.tsx';
import FolderCardSkeleton from './FolderCardSkeleton.tsx';

interface FolderGridProps {
  folders: FolderViewModel[];
  isLoading: boolean;
  onEdit: (folderId: string) => void;
  onDelete: (folderId: string) => void;
}

/**
 * FolderGrid - Component responsible for displaying folder grid or Skeleton components during loading
 */
const FolderGrid: React.FC<FolderGridProps> = ({
  folders,
  isLoading,
  onEdit,
  onDelete,
}) => {
  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
      {isLoading ? (
        // Show skeleton cards while loading
        Array.from({ length: 8 }).map((_, index) => (
          <FolderCardSkeleton key={`skeleton-${index}`} />
        ))
      ) : (
        // Show actual folder cards
        folders.map((folder) => (
          <FolderCard
            key={folder.id}
            folder={folder}
            onEdit={onEdit}
            onDelete={onDelete}
          />
        ))
      )}
    </div>
  );
};

export default FolderGrid;


================================================
FILE: src/components/views/FolderLoadingSpinner.tsx
================================================
import React from 'react';

const FolderLoadingSpinner: React.FC = () => {
  return (
    <div className="flex flex-col items-center justify-center py-16 space-y-6">
      {/* Main spinner with folder icon */}
      <div className="relative">
        {/* Outer rotating ring */}
        <div className="w-16 h-16 border-4 border-gray-200 border-t-blue-600 rounded-full animate-spin"></div>
        
        {/* Inner folder icon */}
        <div className="absolute inset-0 flex items-center justify-center">
          <svg 
            className="w-6 h-6 text-blue-600" 
            fill="currentColor" 
            viewBox="0 0 20 20"
            aria-hidden="true"
          >
            <path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" />
          </svg>
        </div>
      </div>
      
      {/* Loading text */}
      <div className="text-center space-y-2">
        <h3 className="text-xl font-semibold text-gray-900">
          Ładuję szczegóły folderu...
        </h3>
        <p className="text-sm text-gray-600 max-w-md">
          Pobieram informacje o folderze i jego zawartości. To może potrwać chwilę.
        </p>
      </div>

      {/* Animated progress indicators */}
      <div className="flex space-x-2">
        <div className="flex items-center space-x-2 text-sm text-gray-500">
          <div className="w-2 h-2 bg-blue-500 rounded-full animate-bounce"></div>
          <span>Ładuję folder</span>
        </div>
        <div className="flex items-center space-x-2 text-sm text-gray-500">
          <div 
            className="w-2 h-2 bg-blue-500 rounded-full animate-bounce" 
            style={{ animationDelay: '0.3s' }}
          ></div>
          <span>Pobieram fiszki</span>
        </div>
        <div className="flex items-center space-x-2 text-sm text-gray-500">
          <div 
            className="w-2 h-2 bg-blue-500 rounded-full animate-bounce" 
            style={{ animationDelay: '0.6s' }}
          ></div>
          <span>Przygotowuję widok</span>
        </div>
      </div>

      {/* Skeleton placeholder for folder structure */}
      <div className="w-full max-w-md space-y-3 mt-8">
        <div className="h-4 bg-gray-200 rounded animate-pulse"></div>
        <div className="h-3 bg-gray-200 rounded w-3/4 animate-pulse"></div>
        <div className="space-y-2">
          <div className="h-12 bg-gray-100 rounded animate-pulse"></div>
          <div className="h-12 bg-gray-100 rounded animate-pulse"></div>
          <div className="h-12 bg-gray-100 rounded animate-pulse"></div>
        </div>
      </div>
    </div>
  );
};

export default FolderLoadingSpinner;


================================================
FILE: src/components/views/FolderSelect.tsx
================================================
import React from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import type { Folder } from '@/types';

interface FolderSelectProps {
  folders: Folder[];
  selectedFolderId: string;
  customFolderName: string;
  suggestedFolderName: string;
  onFolderSelect: (folderId: string) => void;
  onCustomFolderNameChange: (name: string) => void;
  disabled?: boolean;
}

const FolderSelect: React.FC<FolderSelectProps> = ({
  folders = [], // Default to empty array if folders is undefined
  selectedFolderId,
  customFolderName,
  suggestedFolderName,
  onFolderSelect,
  onCustomFolderNameChange,
  disabled = false,
}) => {
  const [mode, setMode] = React.useState<'existing' | 'new'>('new');

  // Ensure folders is always an array
  const safeFolders = Array.isArray(folders) ? folders : [];

  // Reset selection when switching modes
  React.useEffect(() => {
    if (mode === 'new') {
      onFolderSelect('');
    } else {
      onCustomFolderNameChange('');
    }
  }, [mode, onFolderSelect, onCustomFolderNameChange]);

  // Use suggested name when switching to new folder mode
  React.useEffect(() => {
    if (mode === 'new' && customFolderName === '') {
      onCustomFolderNameChange(suggestedFolderName);
    }
  }, [mode, customFolderName, suggestedFolderName, onCustomFolderNameChange]);

  return (
    <div className="space-y-4">
      {/* Mode selection */}
      <div className="flex space-x-2">
        <Button
          type="button"
          variant={mode === 'new' ? 'default' : 'outline'}
          size="sm"
          onClick={() => setMode('new')}
          disabled={disabled}
        >
          Nowy folder
        </Button>
        <Button
          type="button"
          variant={mode === 'existing' ? 'default' : 'outline'}
          size="sm"
          onClick={() => setMode('existing')}
          disabled={disabled || safeFolders.length === 0}
        >
          Istniejący folder
        </Button>
      </div>

      {/* New folder input */}
      {mode === 'new' && (
        <Card>
          <CardContent className="pt-4">
            <div className="space-y-2">
              <label className="block text-sm font-medium text-gray-700">
                Nazwa nowego folderu:
              </label>
              <input
                type="text"
                value={customFolderName}
                onChange={(e) => onCustomFolderNameChange(e.target.value)}
                placeholder="Wprowadź nazwę folderu..."
                className="w-full p-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                disabled={disabled}
                maxLength={100}
              />
              {suggestedFolderName && customFolderName !== suggestedFolderName && (
                <div className="flex items-center justify-between">
                  <span className="text-xs text-gray-500">
                    Sugerowana nazwa: "{suggestedFolderName}"
                  </span>
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() => onCustomFolderNameChange(suggestedFolderName)}
                    disabled={disabled}
                    className="text-xs"
                  >
                    Użyj sugerowanej
                  </Button>
                </div>
              )}
              <div className="text-xs text-gray-500">
                {customFolderName.length} / 100 znaków
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Existing folder selection */}
      {mode === 'existing' && (
        <Card>
          <CardContent className="pt-4">
            {safeFolders.length === 0 ? (
              <p className="text-gray-500 text-center py-4">
                Brak dostępnych folderów. Utwórz nowy folder.
              </p>
            ) : (
              <div className="space-y-2">
                <label className="block text-sm font-medium text-gray-700">
                  Wybierz folder:
                </label>
                <div className="grid gap-2 max-h-48 overflow-y-auto">
                  {safeFolders.map((folder) => (
                    <Button
                      key={folder.id}
                      type="button"
                      variant={selectedFolderId === folder.id ? 'default' : 'outline'}
                      className="justify-start text-left"
                      onClick={() => onFolderSelect(folder.id)}
                      disabled={disabled}
                    >
                      <div className="flex items-center justify-between w-full">
                        <span className="truncate">{folder.name}</span>
                        <span className="text-xs text-gray-500 ml-2">
                          {folder.created_at ? new Date(folder.created_at).toLocaleDateString() : ''}
                        </span>
                      </div>
                    </Button>
                  ))}
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      )}

      {/* Validation message */}
      {mode === 'new' && customFolderName.trim().length === 0 && (
        <p className="text-xs text-red-600">
          Nazwa folderu nie może być pusta
        </p>
      )}
      
      {mode === 'existing' && !selectedFolderId && safeFolders.length > 0 && (
        <p className="text-xs text-red-600">
          Wybierz folder
        </p>
      )}
    </div>
  );
};

export default FolderSelect;


================================================
FILE: src/components/views/FolderView.tsx
================================================
import React, { useState, useEffect } from 'react';
import LoadingSpinner from './LoadingSpinner';
import FolderLoadingSpinner from './FolderLoadingSpinner';
import FlashcardList from './FlashcardList';
import EditFlashcardDialog from './EditFlashcardDialog';
import DeleteFlashcardDialog from './DeleteFlashcardDialog';
import { Button } from '@/components/ui/button';
import type { FolderViewModel, FlashcardViewModel, Pagination, UpdateFlashcardCommand } from '../../types';

interface FolderViewProps {
  folderId: string;
  userId: string;
}

interface FolderViewState {
  isLoading: boolean;
  error: string | null;
  folder: FolderViewModel | null;
  flashcards: FlashcardViewModel[];
  pagination: Pagination | null;
  editingFlashcard: FlashcardViewModel | null;
  deletingFlashcard: FlashcardViewModel | null;
}

const useFolderState = (folderId: string, userId: string) => {
  const [state, setState] = useState<FolderViewState>({
    isLoading: true,
    error: null,
    folder: null,
    flashcards: [],
    pagination: null,
    editingFlashcard: null,
    deletingFlashcard: null,
  });

  const fetchFolderData = async () => {
    try {
      setState(prev => ({ ...prev, isLoading: true, error: null }));
      
      const response = await fetch(`/api/folders/${folderId}?user_id=${userId}`);
      if (!response.ok) {
        throw new Error(`Failed to fetch folder: ${response.status}`);
      }
      
      const data = await response.json();
      const folderData = data.data;
      setState(prev => ({ ...prev, folder: folderData }));
    } catch (error) {
      setState(prev => ({ 
        ...prev, 
        error: error instanceof Error ? error.message : 'Unknown error occurred' 
      }));
    }
  };

  const fetchFlashcards = async (page: number = 1) => {
    try {
      setState(prev => ({ ...prev, isLoading: true }));
      
      const response = await fetch(`/api/flashcards?folderId=${folderId}&page=${page}&limit=10`);
      if (!response.ok) {
        throw new Error(`Failed to fetch flashcards: ${response.status}`);
      }
      
      const data = await response.json();

      const flashcardsData = data.data.flashcards;
      const paginationData = data.data.pagination;

      setState(prev => ({ 
        ...prev, 
        flashcards: flashcardsData, 
        pagination: paginationData,
        isLoading: false 
      }));
    } catch (error) {
      setState(prev => ({ 
        ...prev, 
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        isLoading: false 
      }));
    }
  };

  const updateFlashcard = async (flashcardId: string, updates: UpdateFlashcardCommand) => {
    try {
      const response = await fetch(`/api/flashcards/${flashcardId}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updates),
      });

      if (!response.ok) {
        throw new Error(`Failed to update flashcard: ${response.status}`);
      }

      const result = await response.json();
      const updatedFlashcard = result.data || result;
      
      setState(prev => ({
        ...prev,
        flashcards: prev.flashcards.map(card => 
          card.id === flashcardId ? updatedFlashcard : card
        ),
        editingFlashcard: null
      }));
    } catch (error) {
      setState(prev => ({ 
        ...prev, 
        error: error instanceof Error ? error.message : 'Failed to update flashcard' 
      }));
    }
  };

  const deleteFlashcard = async (flashcardId: string) => {
    try {
      const response = await fetch(`/api/flashcards/${flashcardId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error(`Failed to delete flashcard: ${response.status}`);
      }

      setState(prev => ({
        ...prev,
        flashcards: prev.flashcards.filter(card => card.id !== flashcardId),
        deletingFlashcard: null,
        folder: prev.folder ? {
          ...prev.folder,
          flashcard_count: prev.folder.flashcard_count - 1
        } : null
      }));
    } catch (error) {
      setState(prev => ({ 
        ...prev, 
        error: error instanceof Error ? error.message : 'Failed to delete flashcard' 
      }));
    }
  };

  const setEditingFlashcard = (flashcard: FlashcardViewModel | null) => {
    setState(prev => ({ ...prev, editingFlashcard: flashcard }));
  };

  const setDeletingFlashcard = (flashcard: FlashcardViewModel | null) => {
    setState(prev => ({ ...prev, deletingFlashcard: flashcard }));
  };

  const changePage = (page: number) => {
    fetchFlashcards(page);
  };

  useEffect(() => {
    fetchFolderData();
    fetchFlashcards();
  }, [folderId, userId]);

  return {
    ...state,
    updateFlashcard,
    deleteFlashcard,
    setEditingFlashcard,
    setDeletingFlashcard,
    changePage,
  };
};

const FolderView: React.FC<FolderViewProps> = ({ folderId, userId }) => {
  const {
    isLoading,
    error,
    folder,
    flashcards,
    pagination,
    editingFlashcard,
    deletingFlashcard,
    updateFlashcard,
    deleteFlashcard,
    setEditingFlashcard,
    setDeletingFlashcard,
    changePage,
  } = useFolderState(folderId, userId);

  if (isLoading && !folder) {
    return (
      <div className="flex items-center justify-center min-h-64">
        <FolderLoadingSpinner />
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center min-h-64">
        <div className="text-center">
          <p className="text-red-600 mb-4">Error: {error}</p>
          <Button onClick={() => window.location.reload()}>
            Try Again
          </Button>
        </div>
      </div>
    );
  }

  if (!folder) {
    return (
      <div className="flex items-center justify-center min-h-64">
        <p className="text-gray-600">Folder not found</p>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      {/* Header Section */}
      <div className="mb-8">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-3xl font-bold text-gray-900 mb-2">{folder.name}</h1>
            <p className="text-gray-600">
              {folder.flashcard_count} {folder.flashcard_count === 1 ? 'fiszka' : 'fiszek'}
            </p>
          </div>
          <div className="flex gap-3">
            <Button 
              size="lg"
              variant="outline" 
              onClick={() => window.location.href = '/dashboard'}
            >
              ← Powrót na pulpit
            </Button>
            {folder.flashcard_count >= 10 && (
              <Button 
                size="lg" 
                className="bg-green-600 hover:bg-green-700"
                onClick={() => window.location.href = `/study/${folderId}`}
              >
                Rozpocznij naukę
              </Button>
            )}
            
          </div>
        </div>
        {folder.flashcard_count > 0 && folder.flashcard_count < 10 && (
          <div className="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
            <p className="text-yellow-800 text-sm">
              Potrzebujesz co najmniej 10 fiszek, aby rozpocząć sesję nauki. 
              Obecnie masz {folder.flashcard_count} {folder.flashcard_count === 1 ? 'fiszkę' : 'fiszek'}.
            </p>
          </div>
        )}
      </div>

      {/* Flashcards List Section */}
      <FlashcardList
        flashcards={flashcards}
        pagination={pagination}
        isLoading={isLoading}
        onPageChange={changePage}
        onEdit={setEditingFlashcard}
        onDelete={setDeletingFlashcard}
      />

      {/* Edit Flashcard Dialog */}
      <EditFlashcardDialog
        isOpen={!!editingFlashcard}
        flashcard={editingFlashcard}
        onClose={() => setEditingFlashcard(null)}
        onSave={updateFlashcard}
      />

      {/* Delete Flashcard Dialog */}
      <DeleteFlashcardDialog
        isOpen={!!deletingFlashcard}
        flashcard={deletingFlashcard}
        onClose={() => setDeletingFlashcard(null)}
        onConfirm={deleteFlashcard}
      />
    </div>
  );
};

export default FolderView;


================================================
FILE: src/components/views/GenerateFlashcardsView.tsx
================================================
import React, { useState, useEffect } from 'react';
import type { Folder, GenerateFlashcardsResponseDTO, BulkSaveFlashcardsCommand, FlashcardProposalViewModel } from '@/types';
import FlashcardGeneratorForm from './FlashcardGeneratorForm';
import FlashcardProposalList from './FlashcardProposalList';
import LoadingSpinner from './LoadingSpinner';

interface GenerateFlashcardsViewProps {
  userId: string;
}

const GenerateFlashcardsView: React.FC<GenerateFlashcardsViewProps> = ({ userId }) => {
  // State management
  const [text, setText] = useState<string>('');
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [suggestedFolderName, setSuggestedFolderName] = useState<string>('');
  const [proposals, setProposals] = useState<FlashcardProposalViewModel[]>([]);
  const [folders, setFolders] = useState<Folder[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [currentStep, setCurrentStep] = useState<'form' | 'loading' | 'proposals'>('form');

  const loadFolders = async () => {
        try {
            const response = await fetch(`/api/folders?user_id=${userId}`);
            if (!response.ok) {
                throw new Error('Failed to load folders');
            }
            const foldersData = await response.json();            
            // Check if the response has the expected structure
            if (foldersData.success && foldersData.data && foldersData.data.folders) {
                setFolders(foldersData.data.folders);
            } else {
                // Handle case where no folders exist (404) or other responses
                console.log('No folders found or invalid response structure');
                setFolders([]);
            }
        } catch (err) {
            console.error('Error loading folders:', err);
            // Don't show error for 404 (no folders found), just set empty array
            if (err instanceof Error && !err.message.includes('404')) {
                setError('Nie udało się załadować folderów. Spróbuj odświeżyć stronę.');
            }
            setFolders([]);
        }
    };
    // Load user folders on component mount
    useEffect(() => {
        loadFolders();
    }, []);

  // Generate unique ID for proposals
  const generateId = (): string => {
    return `proposal-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  };

  // Handle flashcard generation
  const handleGenerate = async (inputText: string) => {
    setIsLoading(true);
    setCurrentStep('loading');
    setError(null);
    
    try {
      const response = await fetch('/api/flashcards/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ text: inputText }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to generate flashcards');
      }

      const responseData = await response.json();
      
      // Check if the response has the expected structure
      if (!responseData.success || !responseData.data) {
        throw new Error(responseData.message || 'Invalid response from server');
      }
      
      const data: GenerateFlashcardsResponseDTO = responseData.data;
      
      // Check if flashcards_proposals exists and is an array
      if (!data.flashcards_proposals || !Array.isArray(data.flashcards_proposals)) {
        throw new Error('No flashcards were generated from the provided text');
      }
      
      // Map API response to ViewModel
      const proposalViewModels: FlashcardProposalViewModel[] = data.flashcards_proposals.map((proposal) => ({
        id: generateId(),
        front: proposal.front,
        back: proposal.back,
        generation_source: proposal.generation_source,
        status: 'pending' as const,
      }));

      setSuggestedFolderName(data.suggested_folder_name);
      setProposals(proposalViewModels);
      setCurrentStep('proposals');
      
      if (proposalViewModels.length === 0) {
        setError('Nie udało się wygenerować fiszek dla podanego tekstu. Spróbuj użyć innego fragmentu.');
      }
    } catch (err) {
      console.error('Error generating flashcards:', err);
      setError(err instanceof Error ? err.message : 'Wystąpił nieoczekiwany błąd. Spróbuj ponownie.');
      setCurrentStep('form');
    } finally {
      setIsLoading(false);
    }
  };

  // Handle proposal updates
  const handleUpdateProposal = (updatedProposal: FlashcardProposalViewModel) => {
    setProposals((prevProposals) =>
      prevProposals.map((proposal) =>
        proposal.id === updatedProposal.id ? updatedProposal : proposal
      )
    );
  };

  // Handle saving flashcards
  const handleSave = async (folderId: string, folderName: string, acceptedFlashcards: FlashcardProposalViewModel[]) => {
    setIsLoading(true);
    setError(null);

    try {
      let targetFolderId = folderId;
      
      // If creating a new folder, first create it
      if (folderId === 'new') {
        const createFolderResponse = await fetch('/api/folders', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            name: folderName,
            user_id: userId,
          }),
        });

        if (!createFolderResponse.ok) {
          const errorData = await createFolderResponse.json();
          throw new Error(errorData.message || 'Failed to create folder');
        }

        const folderResult = await createFolderResponse.json();
        if (folderResult.success && folderResult.data && folderResult.data.folder) {
          targetFolderId = folderResult.data.folder.id;
        } else {
          throw new Error('Invalid response when creating folder');
        }
      }

      const saveCommand: BulkSaveFlashcardsCommand = {
        folder_id: targetFolderId,
        flashcards: acceptedFlashcards.map((card) => ({
          front: card.front,
          back: card.back,
          generation_source: card.generation_source,
        })),
      };

      const response = await fetch('/api/flashcards/bulk-save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(saveCommand),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to save flashcards');
      }

      const result = await response.json();
      
      // Reload folders to show the newly created folder if applicable
      await loadFolders();
      
      // Reset form after successful save
      setText('');
      setProposals([]);
      setSuggestedFolderName('');
      setCurrentStep('form');
      
      // Show success message (could be implemented with toast notification)
      console.log(`Successfully saved ${result.saved_count} flashcards`);
      
    } catch (err) {
      console.error('Error saving flashcards:', err);
      setError(err instanceof Error ? err.message : 'Wystąpił błąd podczas zapisywania fiszek. Spróbuj ponownie.');
    } finally {
      setIsLoading(false);
    }
  };

  // Handle starting over
  const handleStartOver = () => {
    setText('');
    setProposals([]);
    setSuggestedFolderName('');
    setError(null);
    setCurrentStep('form');
  };

  return (
    <div className="container mx-auto py-8 px-4 max-w-4xl">
      <div className="mb-8">
        <div className="flex items-center justify-between mb-4">
          <h1 className="text-3xl font-bold text-gray-900">
            Generuj fiszki z AI
          </h1>
          <button 
            className="px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
            onClick={() => window.location.href = '/dashboard'}
          >
            ← Powrót na pulpit
          </button>
        </div>
        <p className="text-gray-600">
          Wklej tekst, a AI wygeneruje dla Ciebie propozycje fiszek do nauki.
        </p>
      </div>

      {error && (
        <div className="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg">
          <p className="text-red-800">{error}</p>
        </div>
      )}

      {currentStep === 'form' && (
        <FlashcardGeneratorForm
          onGenerate={handleGenerate}
          isLoading={isLoading}
          initialText={text}
          onTextChange={setText}
        />
      )}

      {currentStep === 'loading' && <LoadingSpinner />}

      {currentStep === 'proposals' && (
        <FlashcardProposalList
          proposals={proposals}
          suggestedFolderName={suggestedFolderName}
          folders={folders}
          onUpdateProposal={handleUpdateProposal}
          onSave={handleSave}
          onStartOver={handleStartOver}
          isLoading={isLoading}
        />
      )}
    </div>
  );
};

export default GenerateFlashcardsView;


================================================
FILE: src/components/views/LoadingSpinner.tsx
================================================
import React from 'react';

const LoadingSpinner: React.FC = () => {
  return (
    <div className="flex flex-col items-center justify-center py-12 space-y-4">
      {/* Spinner animation */}
      <div className="relative">
        <div className="w-12 h-12 border-4 border-gray-200 border-t-blue-600 rounded-full animate-spin"></div>
      </div>
      
      {/* Loading text */}
      <div className="text-center space-y-2">
        <h3 className="text-lg font-medium text-gray-900">
          Generuję fiszki...
        </h3>
        <p className="text-sm text-gray-600">
          AI analizuje Twój tekst i tworzy propozycje fiszek. To może potrwać kilka sekund.
        </p>
      </div>

      {/* Progress dots animation */}
      <div className="flex space-x-1">
        <div className="w-2 h-2 bg-blue-600 rounded-full animate-pulse"></div>
        <div className="w-2 h-2 bg-blue-600 rounded-full animate-pulse" style={{ animationDelay: '0.2s' }}></div>
        <div className="w-2 h-2 bg-blue-600 rounded-full animate-pulse" style={{ animationDelay: '0.4s' }}></div>
      </div>
    </div>
  );
};

export default LoadingSpinner;


================================================
FILE: src/components/views/ManualSaveView.tsx
================================================
import React, { useState, useEffect } from 'react';
import type { Folder, CreateFlashcardCommand } from '../../types';
import ManualFlashcardForm from '../forms/ManualFlashcardForm';

interface ManualSaveViewProps {
  userId: string;
}

interface ManualSaveViewState {
  folders: Folder[];
  isLoading: boolean;
  error: string | null;
}

const ManualSaveView: React.FC<ManualSaveViewProps> = ({ userId }) => {
  const [state, setState] = useState<ManualSaveViewState>({
    folders: [],
    isLoading: true,
    error: null,
  });

  // Pobierz foldery przy załadowaniu komponentu
  useEffect(() => {
    const fetchFolders = async () => {
      try {
        setState(prev => ({ ...prev, isLoading: true, error: null }));
        
        const response = await fetch(`/api/folders?user_id=${userId}`);
        
        if (!response.ok) {
          throw new Error(`Failed to fetch folders: ${response.status}`);
        }
        
        const data = await response.json();
        const fetchedFolders = data.data.folders || [];
        setState(prev => ({
          ...prev,
          folders: fetchedFolders || [],
          isLoading: false,
        }));
      } catch (error) {
        console.error('Error fetching folders:', error);
        setState(prev => ({
          ...prev,
          error: error instanceof Error ? error.message : 'Unknown error occurred',
          isLoading: false,
        }));
      }
    };

    fetchFolders();
  }, []);

  // Obsługa tworzenia nowego folderu
  const handleCreateFolder = async (name: string): Promise<Folder> => {
    try {
      const response = await fetch('/api/folders', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          name,
          user_id: userId 
        }),
      });

      if (!response.ok) {
        throw new Error(`Failed to create folder: ${response.status}`);
      }

      const data = await response.json();
      const newFolder = data.data.folder;

      // Dodaj nowy folder do listy
      setState(prev => ({
        ...prev,
        folders: [...prev.folders, newFolder],
      }));

      return newFolder;
    } catch (error) {
      console.error('Error creating folder:', error);
      throw error;
    }
  };

  // Obsługa zapisu fiszki
  const handleSaveFlashcard = async (command: CreateFlashcardCommand): Promise<void> => {
    try {
      const response = await fetch('/api/flashcards', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(command),
      });

      if (!response.ok) {
        throw new Error(`Failed to save flashcard: ${response.status}`);
      }

      // Pokaż powiadomienie o sukcesie (implementacja toast będzie później)
      console.log('Flashcard saved successfully');
    } catch (error) {
      console.error('Error saving flashcard:', error);
      throw error;
    }
  };

  if (state.error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <div className="flex">
          <div className="ml-3">
            <h3 className="text-sm font-medium text-red-800">
              Wystąpił błąd podczas ładowania
            </h3>
            <div className="mt-2 text-sm text-red-700">
              <p>{state.error}</p>
            </div>
            <div className="mt-4">
              <button
                onClick={() => window.location.reload()}
                className="bg-red-100 px-3 py-2 rounded-md text-sm font-medium text-red-800 hover:bg-red-200"
              >
                Spróbuj ponownie
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="bg-white rounded-lg border shadow-sm p-6">
        <div className="mb-6">
          <h2 className="text-xl font-semibold text-gray-900 mb-2">
            Utwórz nową fiszkę
          </h2>
          <p className="text-gray-600">
            Wprowadź treść dla przodu i tyłu fiszki, a następnie wybierz folder lub utwórz nowy.
          </p>
        </div>
        
        <ManualFlashcardForm
          folders={state.folders}
          isLoading={state.isLoading}
          onSave={handleSaveFlashcard}
          onCreateFolder={handleCreateFolder}
        />
      </div>
    </div>
  );
};

export default ManualSaveView;


================================================
FILE: src/components/views/StudySessionView.tsx
================================================
import { useState, useEffect } from 'react';
import type { StudySessionViewModel, FlashcardViewModel } from '@/types';
import StudyFlashcard from '@/components/ui/StudyFlashcard';
import StudyControls from '@/components/ui/StudyControls';
import StudyProgress from '@/components/ui/StudyProgress';
import LoadingSpinnerStudy from '@/components/ui/LoadingSpinnerStudy';
import { Button } from '@/components/ui/button';

interface StudySessionViewProps {
  folderId: string;
}

interface FlashcardsApiResponse {
  flashcards: FlashcardViewModel[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

export default function StudySessionView({ folderId }: StudySessionViewProps) {
  const [sessionState, setSessionState] = useState<StudySessionViewModel>({
    flashcards: [],
    currentCardIndex: 0,
    knownFlashcards: 0,
    status: 'loading',
    error: null,
  });

  const fetchFlashcards = async () => {
    try {
      setSessionState(prev => ({ ...prev, status: 'loading', error: null }));
      
      const response = await fetch(`/api/flashcards?folderId=${folderId}&limit=100`);

      if (!response.ok) {
        throw new Error('Nie udało się pobrać fiszek');
      }

      const data = await response.json();
      const flashCards : FlashcardsApiResponse = data.data; 

      console.log('Pobrane fiszki do nauki:', flashCards);
      
      if (flashCards.flashcards.length === 0) {
        throw new Error('Ten folder nie zawiera żadnych fiszek');
      }

      if (flashCards.flashcards.length < 10) {
        throw new Error('Ten folder zawiera za mało fiszek do sesji nauki (minimum 10)');
      }

      // Wybierz losowe 20 fiszek (lub wszystkie jeśli jest ich mniej niż 20)
      const shuffled = [...flashCards.flashcards].sort(() => 0.5 - Math.random());
      const studyFlashcards = shuffled.slice(0, Math.min(20, flashCards.flashcards.length));

      setSessionState(prev => ({
        ...prev,
        flashcards: studyFlashcards,
        status: 'studying',
        error: null,
      }));
    } catch (error) {
      setSessionState(prev => ({
        ...prev,
        status: 'loading',
        error: error instanceof Error ? error.message : 'Wystąpił nieoczekiwany błąd',
      }));
    }
  };

  useEffect(() => {
    fetchFlashcards();
  }, [folderId]);

  // Keyboard shortcuts for study controls
  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (sessionState.status !== 'studying') return;
      
      if (event.key === 'ArrowLeft' || event.key === '1') {
        event.preventDefault();
        handleDontKnowClick();
      } else if (event.key === 'ArrowRight' || event.key === '2') {
        event.preventDefault();
        handleKnowClick();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [sessionState.status]);

  const handleKnowClick = () => {
    setSessionState(prev => {
      const newKnownCount = prev.knownFlashcards + 1;
      const newIndex = prev.currentCardIndex + 1;
      
      if (newIndex >= prev.flashcards.length) {
        return {
          ...prev,
          knownFlashcards: newKnownCount,
          status: 'finished',
        };
      }
      
      return {
        ...prev,
        currentCardIndex: newIndex,
        knownFlashcards: newKnownCount,
      };
    });
  };

  const handleDontKnowClick = () => {
    setSessionState(prev => {
      const newIndex = prev.currentCardIndex + 1;
      
      if (newIndex >= prev.flashcards.length) {
        return {
          ...prev,
          status: 'finished',
        };
      }
      
      return {
        ...prev,
        currentCardIndex: newIndex,
      };
    });
  };

  const handleRetry = () => {
    fetchFlashcards();
  };

  const handleBackToDashboard = () => {
    window.location.href = '/dashboard';
  };

  const handleBackToFolder = () => {
    window.location.href = `/folders/${folderId}`;
  };

  const handleRestartSession = () => {
    setSessionState(prev => ({
      ...prev,
      currentCardIndex: 0,
      knownFlashcards: 0,
      status: 'studying',
    }));
  };

  if (sessionState.status === 'loading') {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="max-w-2xl mx-auto">
          {sessionState.error ? (
            <div className="text-center space-y-4">
              <h1 className="text-2xl font-bold text-destructive">Błąd</h1>
              <p className="text-muted-foreground">{sessionState.error}</p>
              <div className="flex gap-4 justify-center">
                <Button onClick={handleRetry} variant="default">
                  Spróbuj ponownie
                </Button>
                <Button onClick={handleBackToDashboard} variant="outline">
                  Powrót do pulpitu
                </Button>
              </div>
            </div>
          ) : (
            <LoadingSpinnerStudy />
          )}
        </div>
      </div>
    );
  }

  if (sessionState.status === 'finished') {
    const percentage = Math.round((sessionState.knownFlashcards / sessionState.flashcards.length) * 100);
    
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="max-w-2xl mx-auto text-center space-y-6">
          <h1 className="text-3xl font-bold">Gratulacje!</h1>
          <div className="space-y-2">
            <p className="text-lg">
              Znasz <span className="font-semibold text-primary">{sessionState.knownFlashcards}</span> na{' '}
              <span className="font-semibold">{sessionState.flashcards.length}</span> fiszek
            </p>
            <p className="text-2xl font-bold text-primary">{percentage}%</p>
          </div>
          <div className="flex gap-4 justify-center">
            <Button onClick={handleRestartSession} variant="default">
              Rozpocznij ponownie
            </Button>
            <Button onClick={handleBackToFolder} variant="outline">
              Powrót do folderu
            </Button>
            <Button onClick={handleBackToDashboard} variant="ghost">
              Pulpit
            </Button>
          </div>
        </div>
      </div>
    );
  }

  const currentFlashcard = sessionState.flashcards[sessionState.currentCardIndex];

  return (
    <div className="container mx-auto px-4 py-4 md:py-8">
      <div className="max-w-4xl mx-auto space-y-6 md:space-y-8">
        <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
          <Button 
            onClick={handleBackToFolder} 
            variant="ghost" 
            className="text-muted-foreground hover:text-foreground self-start"
          >
            ← Powrót do folderu
          </Button>
          <div className="w-full sm:w-auto sm:min-w-[200px]">
            <StudyProgress 
              current={sessionState.currentCardIndex + 1} 
              total={sessionState.flashcards.length} 
            />
          </div>
        </div>

        <div className="space-y-6 md:space-y-8">
          <StudyFlashcard flashcard={currentFlashcard} />

          <div className="space-y-4">
            <StudyControls 
              onKnowClick={handleKnowClick}
              onDontKnowClick={handleDontKnowClick}
            />
            
            <div className="text-center">
              <p className="text-sm text-muted-foreground">
                Użyj <kbd className="px-2 py-1 bg-gray-100 rounded text-xs">←</kbd> lub <kbd className="px-2 py-1 bg-gray-100 rounded text-xs">1</kbd> dla "Nie znam" • 
                <kbd className="px-2 py-1 bg-gray-100 rounded text-xs mx-1">→</kbd> lub <kbd className="px-2 py-1 bg-gray-100 rounded text-xs">2</kbd> dla "Znam"
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}


================================================
FILE: src/db/database.types.ts
================================================
[Binary file]


================================================
FILE: src/db/supabase.client.ts
================================================
import { createClient } from "@supabase/supabase-js";
import type { AstroCookies } from "astro";
import { createServerClient, type CookieOptionsWithName } from "@supabase/ssr";

import type { Database } from "../db/database.types";

const supabaseUrl = import.meta.env.SUPABASE_URL;
const supabaseAnonKey = import.meta.env.SUPABASE_KEY;

// Client-side Supabase client (do użytku w komponentach React bez SSR)
export const supabaseClient = createClient<Database>(supabaseUrl, supabaseAnonKey);

export type SupabaseClient = typeof supabaseClient;

// Cookie options dla server-side authentication
export const cookieOptions: CookieOptionsWithName = {
  path: "/",
  secure: true,
  httpOnly: true,
  sameSite: "lax",
};

// Parser dla Cookie header
function parseCookieHeader(cookieHeader: string): { name: string; value: string }[] {
  return cookieHeader.split(";").map((cookie) => {
    const [name, ...rest] = cookie.trim().split("=");
    return { name, value: rest.join("=") };
  });
}

// Server-side Supabase client z obsługą cookies
export const createSupabaseServerInstance = (context: {
  headers: Headers;
  cookies: AstroCookies;
}) => {
  const supabase = createServerClient<Database>(
    import.meta.env.SUPABASE_URL,
    import.meta.env.SUPABASE_KEY,
    {
      cookieOptions,
      cookies: {
        getAll() {
          return parseCookieHeader(context.headers.get("Cookie") ?? "");
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) =>
            context.cookies.set(name, value, options),
          );
        },
      },
    },
  );

  return supabase;
};

export const DEFAULT_FOLDER_ID = "7330b870-9f71-4031-9403-408840bac739";

export const DEFAULT_FLASHCARD_ID = "94d14360-733c-4b0f-81d9-00d22ca251a5";


================================================
FILE: src/layouts/AuthLayout.astro
================================================
---
import "../styles/global.css";

interface Props {
  title?: string;
}

const { title = "10x Cards Flipper" } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
  </head>
  <body>
    <div class="min-h-screen bg-background">
      <!-- Header with navigation for authenticated users -->
      <header class="border-b">
        <div class="container mx-auto px-4 py-4">
          <nav class="flex items-center justify-between">
            <div class="flex items-center space-x-8">
              <a href="/dashboard" class="text-xl font-bold text-primary">
                10x Cards Flipper
              </a>
              <div class="hidden md:flex items-center space-x-6">
                <a href="/dashboard" class="text-sm font-medium text-foreground hover:text-primary transition-colors">
                  Dashboard
                </a>
                <a href="/generate" class="text-sm font-medium text-foreground hover:text-primary transition-colors">
                  Generuj fiszki
                </a>
                <a href="/manual-save" class="text-sm font-medium text-foreground hover:text-primary transition-colors">
                  Dodaj fiszkę
                </a>
              </div>
            </div>
            <div class="flex items-center space-x-4">
              <!-- User email display -->
              {Astro.locals.user && (
                <span class="text-sm text-muted-foreground">
                  {Astro.locals.user.email}
                </span>
              )}
              <!-- Logout button -->
              <button 
                id="logout-btn" 
                type="button"
                class="text-sm font-medium text-foreground hover:text-primary transition-colors"
              >
                Wyloguj
              </button>
            </div>
          </nav>
        </div>
      </header>

      <!-- Main content area -->
      <main class="container mx-auto px-4 py-8">
        <slot />
      </main>
    </div>
  </body>
</html>

<script>
  // Obsługa wylogowania
  const logoutBtn = document.getElementById('logout-btn');
  
  if (logoutBtn) {
    logoutBtn.addEventListener('click', async () => {
      try {
        const response = await fetch('/api/auth/logout', {
          method: 'POST',
        });

        if (response.ok) {
          // Przekieruj do strony logowania po pomyślnym wylogowaniu
          window.location.href = '/login';
        } else {
          console.error('Logout failed');
          // Fallback - przekieruj mimo błędu
          window.location.href = '/login';
        }
      } catch (error) {
        console.error('Logout error:', error);
        // Fallback - przekieruj mimo błędu
        window.location.href = '/login';
      }
    });
  }
</script>

<style>
  html,
  body {
    margin: 0;
    width: 100%;
    height: 100%;
  }
</style>


================================================
FILE: src/layouts/GuestLayout.astro
================================================
---
import "../styles/global.css";

interface Props {
  title?: string;
}

const { title = "10x Cards Flipper" } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
  </head>
  <body>
    <div class="min-h-screen bg-background">
      <!-- Header with simplified navigation for guests -->
      <header class="border-b">
        <div class="container mx-auto px-4 py-4">
          <nav class="flex items-center justify-between">
            <a href="/" class="text-xl font-bold text-primary">
              10x Cards Flipper
            </a>
            <div class="flex items-center space-x-4">
              <a href="/login" class="text-sm font-medium text-foreground hover:text-primary transition-colors">
                Logowanie
              </a>
              <a href="/register" class="text-sm font-medium text-foreground hover:text-primary transition-colors">
                Rejestracja
              </a>
            </div>
          </nav>
        </div>
      </header>

      <!-- Main content area -->
      <main class="flex-1 flex items-center justify-center px-4 py-12">
        <slot />
      </main>
    </div>
  </body>
</html>

<style>
  html,
  body {
    margin: 0;
    width: 100%;
    height: 100%;
  }
</style>


================================================
FILE: src/layouts/Layout.astro
================================================
---
import "../styles/global.css";

interface Props {
  title?: string;
}

const { title = "10x Cards Flipper" } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
  </head>
  <body>
    <slot />
  </body>
</html>

<style>
  html,
  body {
    margin: 0;
    width: 100%;
    height: 100%;
  }
</style>



================================================
FILE: src/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}



================================================
FILE: src/lib/services/flashcardService.ts
================================================
import type { GenerateFlashcardsResponseDTO, CreateFlashcardCommand, FlashcardDTO, UpdateFlashcardCommand, BulkSaveFlashcardsCommand } from "../../types";
import type { SupabaseClient } from "../../db/supabase.client";
/**
 * Service for generating flashcards using AI
 * Currently uses mock data, but can be extended with actual AI integration
 */
export class FlashcardGenerationService {
  private supabase: SupabaseClient;

  constructor(supabaseClient: SupabaseClient) {
    this.supabase = supabaseClient;
  }

  /**
   * Get a flashcard by its ID
   * @param flashcardId - The UUID of the flashcard to retrieve
   * @param userId - User ID 
   * @returns Promise<FlashcardDTO | null> - Flashcard data or null if not found
   * @throws Error if database operation fails
   */
  async getFlashcardById(flashcardId: string, userId: string ): Promise<FlashcardDTO | null> {
    try {
      const { data: flashcardData, error: flashcardError } = await this.supabase
        .from('flashcards')
        .select('id, front, back, folder_id, generation_source, created_at, updated_at')
        .eq('id', flashcardId)
        .eq('user_id', userId) // Ensure user can only access their own flashcards
        .single();

      // Handle not found case
      if (flashcardError) {
        if (flashcardError.code === 'PGRST116') { // PostgREST "no rows returned" error
          return null; // Flashcard not found
        }
        
        // Log and throw for other database errors
        console.error("Database error fetching flashcard:", flashcardError);
        throw new Error("Failed to retrieve flashcard from database");
      }

      if (!flashcardData) {
        return null;
      }

      // Transform to DTO (exclude user_id)
      return {
        id: flashcardData.id,
        front: flashcardData.front,
        back: flashcardData.back,
        folder_id: flashcardData.folder_id,
        generation_source: flashcardData.generation_source,
        created_at: flashcardData.created_at,
        updated_at: flashcardData.updated_at,
      };

    } catch (error) {
      console.error("Error getting flashcard by ID:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to get flashcard");
    }
  }

  /**
   * Get paginated list of flashcards for a user with optional filtering and sorting
   * @param userId - User ID 
   * @param options - Query options for filtering, pagination and sorting
   * @returns Promise<{flashcards: FlashcardDTO[], pagination: PaginationInfo}> - Paginated flashcards data
   * @throws Error if database operation fails
   */
  async getFlashcards(userId: string , options: {
    folderId?: string;
    page: number;
    limit: number;
    sortBy: string;
    order: string;
  }): Promise<{
    flashcards: FlashcardDTO[];
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
    };
  }> {
    try {
      const { folderId, page, limit, sortBy, order } = options;
      const offset = (page - 1) * limit;

      // Build base query
      let query = this.supabase
        .from('flashcards')
        .select('id, front, back, folder_id, generation_source, created_at, updated_at', { count: 'exact' })
        .eq('user_id', userId);

      // Add folder filter if provided
      if (folderId) {
        // First verify that the folder exists and belongs to the user
        const { data: folderData, error: folderError } = await this.supabase
          .from('folders')
          .select('id')
          .eq('id', folderId)
          .eq('user_id', userId)
          .single();

        if (folderError || !folderData) {
          throw new Error("Folder not found or access denied");
        }

        query = query.eq('folder_id', folderId);
      }

      // Add sorting
      query = query.order(sortBy, { ascending: order === 'asc' });

      // Add pagination
      query = query.range(offset, offset + limit - 1);

      // Execute query
      const { data: flashcardsData, error: flashcardsError, count } = await query;

      if (flashcardsError) {
        console.error("Database error fetching flashcards:", flashcardsError);
        throw new Error("Failed to retrieve flashcards from database");
      }

      // Calculate pagination info
      const total = count || 0;
      const totalPages = Math.ceil(total / limit);

      // Transform data to DTOs (exclude user_id)
      const flashcards: FlashcardDTO[] = (flashcardsData || []).map(flashcard => ({
        id: flashcard.id,
        front: flashcard.front,
        back: flashcard.back,
        folder_id: flashcard.folder_id,
        generation_source: flashcard.generation_source,
        created_at: flashcard.created_at,
        updated_at: flashcard.updated_at,
      }));

      return {
        flashcards,
        pagination: {
          page,
          limit,
          total,
          totalPages,
        },
      };

    } catch (error) {
      console.error("Error getting flashcards:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to get flashcards");
    }
  }

  /**
   * Create a new flashcard in the database
   * @param flashcardData - Flashcard data to create
   * @param userId - User ID 
   * @returns Promise<FlashcardDTO> - Created flashcard data
   */
  async createFlashcard(flashcardData: CreateFlashcardCommand, userId: string ): Promise<FlashcardDTO> {
    try {
      // First, verify that the folder exists and belongs to the user
      const { data: folderData, error: folderError } = await this.supabase
        .from('folders')
        .select('id, user_id')
        .eq('id', flashcardData.folder_id)
        .eq('user_id', userId)
        .single();

      if (folderError || !folderData) {
        throw new Error("Folder not found or access denied");
      }

      // Create the flashcard
      const { data: flashcardResult, error: flashcardError } = await this.supabase
        .from('flashcards')
        .insert([{
          front: flashcardData.front,
          back: flashcardData.back,
          folder_id: flashcardData.folder_id,
          generation_source: flashcardData.generation_source,
          user_id: userId,
        }])
        .select('id, front, back, folder_id, generation_source, created_at, updated_at')
        .single();
        console.log("Flashcard creation result:", flashcardResult, flashcardError);
      if (flashcardError || !flashcardResult) {
        console.error("Database error creating flashcard:", flashcardError);
        throw new Error("Failed to create flashcard in database");
      }

      // Return the flashcard data as DTO (without user_id)
      return {
        id: flashcardResult.id,
        front: flashcardResult.front,
        back: flashcardResult.back,
        folder_id: flashcardResult.folder_id,
        generation_source: flashcardResult.generation_source,
        created_at: flashcardResult.created_at,
        updated_at: flashcardResult.updated_at,
      };

    } catch (error) {
      console.error("Error creating flashcard:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to create flashcard");
    }
  }

  /**
   * Update an existing flashcard
   * @param flashcardId - The UUID of the flashcard to update
   * @param updateData - Data to update the flashcard with
   * @param userId - User ID 
   * @returns Promise<FlashcardDTO> - Updated flashcard data
   * @throws Error if flashcard not found, folder not found, or database operation fails
   */
  async updateFlashcard(
    flashcardId: string, 
    updateData: UpdateFlashcardCommand, 
    userId: string 
  ): Promise<FlashcardDTO> {
    try {
      // First, verify that the flashcard exists and belongs to the user
      const { data: existingFlashcard, error: flashcardError } = await this.supabase
        .from('flashcards')
        .select('id, folder_id, user_id')
        .eq('id', flashcardId)
        .eq('user_id', userId)
        .single();

      if (flashcardError) {
        if (flashcardError.code === 'PGRST116') { // PostgREST "no rows returned" error
          throw new Error("Flashcard not found or access denied");
        }
        
        console.error("Database error fetching flashcard for update:", flashcardError);
        throw new Error("Failed to retrieve flashcard from database");
      }

      if (!existingFlashcard) {
        throw new Error("Flashcard not found or access denied");
      }

      // If folder_id is being updated, verify the new folder exists and belongs to the user
      if (updateData.folder_id && updateData.folder_id !== existingFlashcard.folder_id) {
        const { data: folderData, error: folderError } = await this.supabase
          .from('folders')
          .select('id, user_id')
          .eq('id', updateData.folder_id)
          .eq('user_id', userId)
          .single();

        if (folderError || !folderData) {
          throw new Error("Folder not found or access denied");
        }
      }

      // Prepare update data
      const updatePayload: any = {
        front: updateData.front,
        back: updateData.back,
        generation_source: updateData.generation_source,
        updated_at: new Date().toISOString(),
      };

      // Only update folder_id if it's provided
      if (updateData.folder_id) {
        updatePayload.folder_id = updateData.folder_id;
      }

      // Update the flashcard
      const { data: updatedFlashcard, error: updateError } = await this.supabase
        .from('flashcards')
        .update(updatePayload)
        .eq('id', flashcardId)
        .eq('user_id', userId) // Extra security check
        .select('id, front, back, folder_id, generation_source, created_at, updated_at')
        .single();

      if (updateError || !updatedFlashcard) {
        console.error("Database error updating flashcard:", updateError);
        throw new Error("Failed to update flashcard in database");
      }

      // Return the updated flashcard data as DTO (without user_id)
      return {
        id: updatedFlashcard.id,
        front: updatedFlashcard.front,
        back: updatedFlashcard.back,
        folder_id: updatedFlashcard.folder_id,
        generation_source: updatedFlashcard.generation_source,
        created_at: updatedFlashcard.created_at,
        updated_at: updatedFlashcard.updated_at,
      };

    } catch (error) {
      console.error("Error updating flashcard:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to update flashcard");
    }
  }

  /**
   * Generate flashcards from provided text
   * @param text - Input text to generate flashcards from (max 5000 characters)
   * @returns Promise<GenerateFlashcardsResponseDTO> - Generated flashcards with suggested folder name
   * 
   * Authentication will be implemented comprehensively later.
   */
  async generateFlashcards(text: string): Promise<GenerateFlashcardsResponseDTO> {
    try {
      // Simulate processing time for AI call
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Extract key concepts from text for mock generation
      const mockResponse = this.generateMockFlashcards(text);
      
      return mockResponse;
    } catch (error) {
      console.error("Error generating flashcards:", error);
      throw new Error("Failed to generate flashcards from provided text");
    }
  }

  /**
   * Generate mock flashcards based on text analysis
   * This will be replaced with actual AI integration in the future
   * @param text - Input text
   * @returns GenerateFlashcardsResponseDTO - Mock response
   */
  private generateMockFlashcards(text: string): GenerateFlashcardsResponseDTO {
    // Simple text analysis for mock purposes
    const wordCount = text.split(/\s+/).length;
    const textLength = text.length;
    
    // Generate suggested folder name based on text content
    const firstWords = text.split(/\s+/).slice(0, 3).join(" ");
    const suggestedName = firstWords.length > 30 
      ? `${firstWords.substring(0, 30)}...` 
      : `Study Notes - ${firstWords}`;

    // Generate mock flashcards based on text characteristics
    const flashcardsProposals = [];

    // Basic flashcard about text length and structure
    flashcardsProposals.push({
      front: "What is the approximate length of the provided text?",
      back: `The text contains approximately ${wordCount} words and ${textLength} characters.`,
      generation_source: "ai" as const,
    });

    // If text is long enough, create more specific flashcards
    if (wordCount > 20) {
      flashcardsProposals.push({
        front: "What is the main topic discussed in this text?",
        back: `Based on the content analysis, the text appears to discuss: ${firstWords}`,
        generation_source: "ai" as const,
      });
    }

    if (wordCount > 50) {
      // Try to find questions or important statements
      const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 10);
      if (sentences.length > 1) {
        const keysentence = sentences[0].trim();
        flashcardsProposals.push({
          front: "What is one of the key points mentioned in the text?",
          back: keysentence.length > 200 ? `${keysentence.substring(0, 200)}...` : keysentence,
          generation_source: "ai" as const,
        });
      }
    }

    // Always include at least 2 flashcards
    if (flashcardsProposals.length < 2) {
      flashcardsProposals.push({
        front: "What type of content was provided for flashcard generation?",
        back: "The content appears to be educational or informational text suitable for creating study materials.",
        generation_source: "ai" as const,
      });
    }

    return {
      suggested_folder_name: suggestedName,
      flashcards_proposals: flashcardsProposals,
    };
  }

  /**
   * Bulk save multiple flashcards to a specific folder
   * Used primarily for saving AI-generated flashcards that user has accepted
   * @param bulkData - Bulk save command containing folder_id and flashcards array
   * @param userId - User ID from authenticated session
   * @returns Promise<{saved_count: number, flashcard_ids: string[], message: string}> - Bulk save result
   * @throws Error if folder not found, access denied, or database operation fails
   */
  async bulkSaveFlashcards(
    bulkData: BulkSaveFlashcardsCommand, 
    userId: string
  ): Promise<{
    saved_count: number;
    flashcard_ids: string[];
    message: string;
  }> {
    try {
      // Verify that the folder exists and belongs to the user
      const { data: folderData, error: folderError } = await this.supabase
        .from('folders')
        .select('id, user_id, name')
        .eq('id', bulkData.folder_id)
        .eq('user_id', userId)
        .single();

      if (folderError) {
        if (folderError.code === 'PGRST116') { // PostgREST "no rows returned" error
          throw new Error("Folder not found or access denied");
        }
        
        console.error("Database error fetching folder for bulk save:", folderError);
        throw new Error("Failed to retrieve folder from database");
      }

      if (!folderData) {
        throw new Error("Folder not found or access denied");
      }

      // Prepare flashcards data for bulk insert
      const flashcardsToInsert = bulkData.flashcards.map(flashcard => ({
        front: flashcard.front,
        back: flashcard.back,
        folder_id: bulkData.folder_id,
        generation_source: flashcard.generation_source,
        user_id: userId,
      }));

      // Use Supabase transaction-like bulk insert
      const { data: insertedFlashcards, error: insertError } = await this.supabase
        .from('flashcards')
        .insert(flashcardsToInsert)
        .select('id, front, back, folder_id, generation_source, created_at, updated_at');

      if (insertError || !insertedFlashcards) {
        console.error("Database error during bulk insert:", insertError);
        throw new Error("Failed to save flashcards to database");
      }

      // Extract IDs of successfully created flashcards
      const flashcardIds = insertedFlashcards.map(flashcard => flashcard.id);
      const savedCount = insertedFlashcards.length;

      console.log(`Successfully saved ${savedCount} flashcards to folder: ${folderData.name}`);

      return {
        saved_count: savedCount,
        flashcard_ids: flashcardIds,
        message: `Successfully saved ${savedCount} flashcard${savedCount > 1 ? 's' : ''} to folder "${folderData.name}"`,
      };

    } catch (error) {
      console.error("Error in bulk save flashcards:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to bulk save flashcards");
    }
  }

  /**
   * Delete a flashcard by ID
   * @param flashcardId - The UUID of the flashcard to delete
   * @param userId - User ID 
   * @returns Promise<void> - No data returned on successful deletion
   * @throws Error if flashcard not found, access denied, or database operation fails
   */
  async deleteFlashcard(flashcardId: string, userId: string): Promise<void> {
    try {
      // First, verify that the flashcard exists and belongs to the user
      const { data: existingFlashcard, error: flashcardError } = await this.supabase
        .from('flashcards')
        .select('id, user_id')
        .eq('id', flashcardId)
        .eq('user_id', userId)
        .single();

      if (flashcardError) {
        if (flashcardError.code === 'PGRST116') { // PostgREST "no rows returned" error
          throw new Error("Flashcard not found or access denied");
        }
        
        console.error("Database error fetching flashcard for deletion:", flashcardError);
        throw new Error("Failed to retrieve flashcard from database");
      }

      if (!existingFlashcard) {
        throw new Error("Flashcard not found or access denied");
      }

      // Delete the flashcard
      const { error: deleteError } = await this.supabase
        .from('flashcards')
        .delete()
        .eq('id', flashcardId)
        .eq('user_id', userId); // Extra security check to ensure user can only delete their own flashcards

      if (deleteError) {
        console.error("Database error deleting flashcard:", deleteError);
        throw new Error("Failed to delete flashcard from database");
      }

      // No data returned on successful deletion
      return;

    } catch (error) {
      console.error("Error deleting flashcard:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to delete flashcard");
    }
  }

  /**
   * Future method for actual AI integration
   * This will be implemented when integrating with GPT-4o-mini API
   * @param text - Input text
   * @returns Promise<GenerateFlashcardsResponseDTO> - AI generated response
   */
  private async callAIService(text: string): Promise<GenerateFlashcardsResponseDTO> {
    // TODO: Implement actual AI API call
    // This would include:
    // 1. Formatting the prompt for GPT-4o-mini
    // 2. Making the API call with proper error handling
    // 3. Parsing and validating the AI response
    // 4. Handling timeouts (60 seconds as per requirements)
    
    // Example of future database integration:
    // const { data, error } = await this.supabase
    //   .from('flashcards')
    //   .insert([{ front: '...', back: '...', user_id:  }]);
    
    throw new Error("AI service integration not yet implemented");
  }
}


================================================
FILE: src/lib/services/folderService.ts
================================================
import type { FolderDTO, CreateFolderCommand, UpdateFolderCommand } from "../../types";
import type { SupabaseClient } from "../../db/supabase.client";

/**
 * Service for managing folders
 * Handles all folder-related database operations with proper validation and error handling
 */
export class FolderService {
  private supabase: SupabaseClient;

  constructor(supabaseClient: SupabaseClient) {
    this.supabase = supabaseClient;
  }

  /**
   * Get paginated list of folders for a specific user
   * @param userId - User ID to filter folders by
   * @param options - Query options for pagination
   * @returns Promise<{folders: FolderDTO[], pagination: PaginationInfo}> - Paginated folders data
   * @throws Error if database operation fails or user validation fails
   */
  async getUserFolders(userId: string, options: {
    page: number;
    limit: number;
  }): Promise<{
    folders: FolderDTO[];
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
    };
  }> {
    try {
      const { page, limit } = options;
      const offset = (page - 1) * limit;

      // Validate UUID format for user_id
      if (!this.isValidUUID(userId)) {
        throw new Error("Invalid user ID format");
      }

      // Build query with count for pagination
      let query = this.supabase
        .from('folders')
        .select('id, name, created_at, updated_at', { count: 'exact' })
        .eq('user_id', userId)
        .order('created_at', { ascending: false }) // Most recent first
        .range(offset, offset + limit - 1);

      // Execute query
      const { data: foldersData, error: foldersError, count } = await query;

      if (foldersError) {
        console.error("Database error fetching folders:", foldersError);
        throw new Error("Failed to retrieve folders from database");
      }

      // Calculate pagination info
      const total = count || 0;
      const totalPages = Math.ceil(total / limit);

      // Transform data to DTOs (exclude user_id)
      const folders: FolderDTO[] = (foldersData || []).map(folder => ({
        id: folder.id,
        name: folder.name,
        created_at: folder.created_at,
        updated_at: folder.updated_at,
      }));

      return {
        folders,
        pagination: {
          page,
          limit,
          total,
          totalPages,
        },
      };

    } catch (error) {
      console.error("Error getting user folders:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to get folders");
    }
  }

  /**
   * Get detailed information about a specific folder including flashcard count
   * @param folderId - ID of the folder to retrieve
   * @param userId - User ID to verify ownership
   * @returns Promise<FolderDTO> - Folder details with flashcard count
   * @throws Error if folder not found, access denied, or database operation fails
   */
  async getFolderDetails(folderId: string, userId: string): Promise<FolderDTO & { flashcard_count: number }> {
    try {
      // Validate UUID format for both parameters
      if (!this.isValidUUID(folderId)) {
        throw new Error("Invalid folder ID format");
      }

      if (!this.isValidUUID(userId)) {
        throw new Error("Invalid user ID format");
      }

      // Query folder with user_id verification to ensure ownership
      const { data: folderData, error: folderError } = await this.supabase
        .from('folders')
        .select('id, name, created_at, updated_at')
        .eq('id', folderId)
        .eq('user_id', userId)
        .single();

      if (folderError) {
        if (folderError.code === 'PGRST116') {
          // No rows returned - folder not found or not owned by user
          throw new Error("Folder not found or access denied");
        }
        console.error("Database error fetching folder:", folderError);
        throw new Error("Failed to retrieve folder from database");
      }

      if (!folderData) {
        throw new Error("Folder not found or access denied");
      }

      // Query flashcard count for this folder
      const { count: flashcardCount, error: countError } = await this.supabase
        .from('flashcards')
        .select('*', { count: 'exact', head: true })
        .eq('folder_id', folderId)
        .eq('user_id', userId);

      if (countError) {
        console.error("Database error counting flashcards:", countError);
        throw new Error("Failed to retrieve flashcard count from database");
      }

      // Transform data to DTO format (exclude user_id) and add flashcard count
      const folderDetails: FolderDTO & { flashcard_count: number } = {
        id: folderData.id,
        name: folderData.name,
        created_at: folderData.created_at,
        updated_at: folderData.updated_at,
        flashcard_count: flashcardCount || 0,
      };

      return folderDetails;

    } catch (error) {
      console.error("Error getting folder details:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to get folder details");
    }
  }

  /**
   * Create a new folder for a specific user
   * @param folderData - Data for creating the folder including user_id
   * @returns Promise<FolderDTO> - Created folder data
   * @throws Error if folder name already exists for user, validation fails, or database operation fails
   */
  async createFolder(folderData: CreateFolderCommand): Promise<FolderDTO> {
    try {
      // Validate UUID format for user_id
      if (!this.isValidUUID(folderData.user_id)) {
        throw new Error("Invalid user ID format");
      }

      // Check if folder with same name already exists for this user
      const { data: existingFolder, error: checkError } = await this.supabase
        .from('folders')
        .select('id')
        .eq('user_id', folderData.user_id)
        .eq('name', folderData.name)
        .single();

      if (checkError && checkError.code !== 'PGRST116') {
        // PGRST116 means no rows found, which is what we want
        console.error("Database error checking existing folder:", checkError);
        throw new Error("Failed to validate folder uniqueness");
      }

      if (existingFolder) {
        throw new Error("A folder with this name already exists");
      }

      // Create the new folder
      const { data: newFolder, error: insertError } = await this.supabase
        .from('folders')
        .insert([
          {
            name: folderData.name,
            user_id: folderData.user_id,
          }
        ])
        .select('id, name, created_at, updated_at')
        .single();

      if (insertError) {
        console.error("Database error creating folder:", insertError);
        
        // Handle specific database constraints
        if (insertError.code === '23505') {
          // Unique constraint violation
          throw new Error("A folder with this name already exists");
        }
        
        throw new Error("Failed to create folder in database");
      }

      if (!newFolder) {
        throw new Error("Failed to create folder - no data returned");
      }

      // Transform data to DTO format (exclude user_id)
      const folderDTO: FolderDTO = {
        id: newFolder.id,
        name: newFolder.name,
        created_at: newFolder.created_at,
        updated_at: newFolder.updated_at,
      };

      return folderDTO;

    } catch (error) {
      console.error("Error creating folder:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to create folder");
    }
  }

  /**
   * Update an existing folder's name
   * @param folderId - ID of the folder to update
   * @param userId - User ID to verify ownership
   * @param updateData - Data for updating the folder
   * @returns Promise<FolderDTO> - Updated folder data
   * @throws Error if folder not found, access denied, name already exists, or database operation fails
   */
  async updateFolder(folderId: string, userId: string, updateData: UpdateFolderCommand): Promise<FolderDTO> {
    try {
      // Validate UUID format for both parameters
      if (!this.isValidUUID(folderId)) {
        throw new Error("Invalid folder ID format");
      }

      if (!this.isValidUUID(userId)) {
        throw new Error("Invalid user ID format");
      }

      // Validate folder name is not empty
      if (!updateData.name || updateData.name.trim().length === 0) {
        throw new Error("Folder name cannot be empty");
      }

      // Trim the name to prevent whitespace-only names
      const trimmedName = updateData.name.trim();

      // First, verify the folder exists and belongs to the user
      const { data: existingFolder, error: checkError } = await this.supabase
        .from('folders')
        .select('id, name')
        .eq('id', folderId)
        .eq('user_id', userId)
        .single();

      if (checkError) {
        if (checkError.code === 'PGRST116') {
          // No rows returned - folder not found or not owned by user
          throw new Error("Folder not found or access denied");
        }
        console.error("Database error checking folder ownership:", checkError);
        throw new Error("Failed to verify folder ownership");
      }

      if (!existingFolder) {
        throw new Error("Folder not found or access denied");
      }

      // Check if the new name is different from the current name
      if (existingFolder.name === trimmedName) {
        // Name hasn't changed, return current folder data
        const folderDetails = await this.getFolderDetails(folderId, userId);
        // Return without flashcard_count for consistency with update operation
        const { flashcard_count, ...folderDTO } = folderDetails;
        return folderDTO;
      }

      // Check if another folder with the same name already exists for this user
      const { data: duplicateFolder, error: duplicateError } = await this.supabase
        .from('folders')
        .select('id')
        .eq('user_id', userId)
        .eq('name', trimmedName)
        .neq('id', folderId) // Exclude current folder
        .single();

      if (duplicateError && duplicateError.code !== 'PGRST116') {
        // PGRST116 means no rows found, which is what we want
        console.error("Database error checking duplicate folder name:", duplicateError);
        throw new Error("Failed to validate folder name uniqueness");
      }

      if (duplicateFolder) {
        throw new Error("A folder with this name already exists");
      }

      // Update the folder
      const { data: updatedFolder, error: updateError } = await this.supabase
        .from('folders')
        .update({
          name: trimmedName,
          updated_at: new Date().toISOString()
        })
        .eq('id', folderId)
        .eq('user_id', userId)
        .select('id, name, created_at, updated_at')
        .single();

      if (updateError) {
        console.error("Database error updating folder:", updateError);
        
        // Handle specific database constraints
        if (updateError.code === '23505') {
          // Unique constraint violation
          throw new Error("A folder with this name already exists");
        }
        
        throw new Error("Failed to update folder in database");
      }

      if (!updatedFolder) {
        throw new Error("Failed to update folder - no data returned");
      }

      // Transform data to DTO format (exclude user_id)
      const folderDTO: FolderDTO = {
        id: updatedFolder.id,
        name: updatedFolder.name,
        created_at: updatedFolder.created_at,
        updated_at: updatedFolder.updated_at,
      };

      return folderDTO;

    } catch (error) {
      console.error("Error updating folder:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to update folder");
    }
  }

  /**
   * Delete a folder and all associated flashcards (cascade delete)
   * @param folderId - ID of the folder to delete
   * @param userId - User ID to verify ownership
   * @returns Promise<void> - Resolves when folder is successfully deleted
   * @throws Error if folder not found, access denied, or database operation fails
   */
  async deleteFolder(folderId: string, userId: string): Promise<void> {
    try {
      // Validate UUID format for both parameters
      if (!this.isValidUUID(folderId)) {
        throw new Error("Invalid folder ID format");
      }

      if (!this.isValidUUID(userId)) {
        throw new Error("Invalid user ID format");
      }

      // First, verify the folder exists and belongs to the user
      const { data: existingFolder, error: checkError } = await this.supabase
        .from('folders')
        .select('id')
        .eq('id', folderId)
        .eq('user_id', userId)
        .single();

      if (checkError) {
        if (checkError.code === 'PGRST116') {
          // No rows returned - folder not found or not owned by user
          throw new Error("Folder not found or access denied");
        }
        console.error("Database error checking folder ownership:", checkError);
        throw new Error("Failed to verify folder ownership");
      }

      if (!existingFolder) {
        throw new Error("Folder not found or access denied");
      }

      // Delete the folder (flashcards will be deleted automatically due to CASCADE constraint)
      const { error: deleteError } = await this.supabase
        .from('folders')
        .delete()
        .eq('id', folderId)
        .eq('user_id', userId);

      if (deleteError) {
        console.error("Database error deleting folder:", deleteError);
        throw new Error("Failed to delete folder from database");
      }

    } catch (error) {
      console.error("Error deleting folder:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to delete folder");
    }
  }

  /**
   * Validates if a string is a valid UUID format
   * @param uuid - String to validate
   * @returns boolean - True if valid UUID format
   */
  private isValidUUID(uuid: string): boolean {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    return uuidRegex.test(uuid);
  }
}


================================================
FILE: src/lib/services/openRouterService.ts
================================================
/**
 * OpenRouter Service - serwis do komunikacji z API OpenRouter.ai
 * Odpowiedzialny za generowanie fiszek przy użyciu modeli językowych (LLM)
 */

// ===================================================================
// TYPY I INTERFEJSY
// ===================================================================

/**
 * Interfejs reprezentujący pojedynczą fiszkę wygenerowaną przez AI
 */
export interface Flashcard {
  question: string;
  answer: string;
}

/**
 * Interfejs reprezentujący ustrukturyzowaną odpowiedź z API OpenRouter
 */
export interface StructuredResponse {
  flashcards: Flashcard[];
  title: string;
}

/**
 * Interfejs dla błędów związanych z API
 */
export class ApiError extends Error {
  constructor(
    message: string,
    public readonly status: number,
    public readonly responseBody: string
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

/**
 * Interfejs dla błędów związanych z połączeniem
 */
export class ApiConnectionError extends Error {
  constructor(message: string, public readonly originalError: Error) {
    super(message);
    this.name = 'ApiConnectionError';
  }
}

/**
 * Interfejs dla błędów związanych z parsowaniem odpowiedzi
 */
export class InvalidResponseError extends Error {
  constructor(message: string, public readonly responseData?: any) {
    super(message);
    this.name = 'InvalidResponseError';
  }
}

/**
 * Interfejs dla błędów związanych z timeout
 */
export class TimeoutError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'TimeoutError';
  }
}

// ===================================================================
// KLASA SERWISU
// ===================================================================

/**
 * OpenRouterService - główna klasa serwisu do komunikacji z OpenRouter API
 * 
 * Responsibilities:
 * - Zarządzanie konfiguracją API (klucz, endpoint)
 * - Wysyłanie zapytań do modeli językowych
 * - Parsowanie i walidacja odpowiedzi
 * - Obsługa błędów i timeout
 */
export class OpenRouterService {
  private readonly openRouterApiKey: string;
  private readonly openRouterApiUrl = "https://openrouter.ai/api/v1/chat/completions";
  private readonly requestTimeout = 30000; // 30 sekund

  /**
   * Konstruktor serwisu OpenRouter
   * Inicjalizuje klucz API i waliduje konfigurację
   * 
   * @throws {Error} Jeśli klucz API nie jest dostępny w zmiennych środowiskowych
   */
  constructor() {
    // Wczytanie klucza API ze zmiennych środowiskowych
    // Zgodnie z dokumentacją Astro, używamy `import.meta.env`
    const apiKey = import.meta.env.OPENROUTER_API_KEY;

    if (!apiKey) {
      // Rzucenie błędu, jeśli klucz API nie jest dostępny
      throw new Error("OPENROUTER_API_KEY is not set in environment variables.");
    }
    
    this.openRouterApiKey = apiKey;
  }

  /**
   * Główna metoda publiczna do generowania fiszek
   * 
   * @param prompt - Tekst wejściowy od użytkownika, na podstawie którego generowane będą fiszki
   * @param modelName - Nazwa modelu do użycia (np. "anthropic/claude-3.5-sonnet")
   * @returns Promise<StructuredResponse> - Obiekt zawierający wygenerowane fiszki i tytuł
   * 
   * @throws {ApiError} Błędy związane z API (4xx, 5xx)
   * @throws {ApiConnectionError} Błędy połączenia sieciowego
   * @throws {InvalidResponseError} Błędy parsowania odpowiedzi
   * @throws {TimeoutError} Błędy timeout
   */
  public async generateFlashcards(prompt: string, modelName: string): Promise<StructuredResponse> {
    // Walidacja parametrów wejściowych
    if (!prompt?.trim()) {
      throw new Error("Prompt cannot be empty");
    }
    
    if (!modelName?.trim()) {
      throw new Error("Model name cannot be empty");
    }

    // Definicja komunikatu systemowego w języku polskim
    const systemMessage = `Jesteś ekspertem w tworzeniu fiszek do nauki. Twoim zadaniem jest wygenerowanie zestawu fiszek na podstawie dostarczonego tekstu. 

Zasady tworzenia fiszek:
1. Każda fiszka powinna zawierać konkretne pytanie i jasną odpowiedź
2. Pytania powinny być zróżnicowane (definicje, przykłady, zastosowania, porównania)
3. Odpowiedzi powinny być zwięzłe ale kompletne
4. Unikaj powtarzania tych samych informacji w różnych fiszkach
5. Skoncentruj się na najważniejszych pojęciach z podanego tekstu

Odpowiedź musi być w formacie JSON zgodnym z podanym schematem.`;
    
    // Definicja schematu JSON dla structured output
    const responseFormat = {
      type: 'json_schema',
      json_schema: {
        name: 'flashcardSet',
        strict: true,
        schema: {
          type: 'object',
          properties: {
            title: { 
              type: 'string', 
              description: 'Tytuł zestawu fiszek, powiązany z głównym tematem podanego tekstu. Maksymalnie 50 znaków.' 
            },
            flashcards: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  question: { 
                    type: 'string', 
                    description: 'Pytanie na fiszce. Powinno być jasne i konkretne.' 
                  },
                  answer: { 
                    type: 'string', 
                    description: 'Odpowiedź na fiszce. Powinna być zwięzła ale kompletna.' 
                  }
                },
                required: ['question', 'answer'],
                additionalProperties: false
              },
              minItems: 3,
              maxItems: 15,
              description: 'Lista fiszek wygenerowanych na podstawie podanego tekstu.'
            }
          },
          required: ['title', 'flashcards'],
          additionalProperties: false
        }
      }
    };

    // Budowanie payloadu zapytania
    const payload = this.buildRequestPayload(systemMessage, prompt, modelName, responseFormat);
    
    // Wysłanie zapytania do API
    const apiResponse = await this.sendRequest(payload);
    
    // Parsowanie i walidacja odpowiedzi
    return this.parseAndValidateResponse(apiResponse);
  }

  // ===================================================================
  // METODY PRYWATNE
  // ===================================================================

  /**
   * Buduje payload zapytania do API OpenRouter
   * 
   * @param systemMessage - Komunikat systemowy definiujący rolę i zasady
   * @param userMessage - Wiadomość użytkownika (prompt)
   * @param modelName - Nazwa modelu do użycia
   * @param responseFormat - Format odpowiedzi (JSON schema)
   * @returns Obiekt payload do wysłania
   */
  private buildRequestPayload(
    systemMessage: string, 
    userMessage: string, 
    modelName: string, 
    responseFormat: object
  ): object {
    return {
      model: modelName,
      messages: [
        { role: 'system', content: systemMessage },
        { role: 'user', content: userMessage }
      ],
      response_format: responseFormat,
      temperature: 0.7, // Balans między kreatywnością a spójnością
      max_tokens: 4000, // Limit tokenów dla odpowiedzi
    };
  }

  /**
   * Wysyła zapytanie POST do API OpenRouter
   * 
   * @param payload - Obiekt danych do wysłania
   * @returns Promise<any> - Surowa odpowiedź z API
   * 
   * @throws {TimeoutError} Jeśli zapytanie przekroczy timeout
   * @throws {ApiError} Jeśli API zwróci błąd (4xx, 5xx)
   * @throws {ApiConnectionError} Jeśli wystąpi błąd połączenia
   */
  private async sendRequest(payload: object): Promise<any> {
    // Konfiguracja AbortController dla timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.requestTimeout);

    try {
      const response = await fetch(this.openRouterApiUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.openRouterApiKey}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': 'https://10x-cards-flipper.com', // Opcjonalne dla statystyk
          'X-Title': '10x Cards Flipper', // Opcjonalne dla statystyk
        },
        body: JSON.stringify(payload),
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      // Obsługa błędów HTTP
      if (!response.ok) {
        const errorBody = await response.text();
        
        // Logowanie błędu dla debugowania (bez wrażliwych danych)
        console.error(`OpenRouter API Error: ${response.status} ${response.statusText}`);
        
        throw new ApiError(
          `API Error: ${response.status} ${response.statusText}`,
          response.status,
          errorBody
        );
      }

      return await response.json();
      
    } catch (error) {
      clearTimeout(timeoutId);
      
      // Obsługa różnych typów błędów
      if (error instanceof Error && error.name === 'AbortError') {
        throw new TimeoutError(`Request timed out after ${this.requestTimeout / 1000} seconds.`);
      }
      
      // Jeśli to już nasz custom error, przekaż dalej
      if (error instanceof ApiError || error instanceof TimeoutError) {
        throw error;
      }
      
      // Błędy połączenia sieciowego
      throw new ApiConnectionError(
        'Failed to connect to OpenRouter API. Please check your internet connection.',
        error instanceof Error ? error : new Error(String(error))
      );
    }
  }

  /**
   * Parsuje i waliduje odpowiedź z API OpenRouter
   * 
   * @param apiResponse - Surowa odpowiedź z API
   * @returns StructuredResponse - Sparsowana i zwalidowana odpowiedź
   * 
   * @throws {InvalidResponseError} Jeśli odpowiedź ma niepoprawną strukturę lub zawartość
   */
  private parseAndValidateResponse(apiResponse: any): StructuredResponse {
    try {
      // Sprawdzenie podstawowej struktury odpowiedzi
      if (!apiResponse?.choices?.length) {
        throw new InvalidResponseError('Invalid API response structure: no choices found.', apiResponse);
      }

      const content = apiResponse.choices[0]?.message?.content;
      if (!content) {
        throw new InvalidResponseError('Invalid API response structure: content is missing.', apiResponse);
      }
      
      // Parsowanie JSON
      let parsedContent: StructuredResponse;
      try {
        parsedContent = JSON.parse(content);
      } catch (jsonError) {
        throw new InvalidResponseError('Failed to parse JSON content from API response.', { content, jsonError });
      }

      // Walidacja struktury odpowiedzi
      if (!parsedContent || typeof parsedContent !== 'object') {
        throw new InvalidResponseError('Parsed content is not a valid object.', parsedContent);
      }

      if (!parsedContent.title || typeof parsedContent.title !== 'string') {
        throw new InvalidResponseError('Validation failed: title is missing or invalid.', parsedContent);
      }

      if (!Array.isArray(parsedContent.flashcards)) {
        throw new InvalidResponseError('Validation failed: flashcards should be an array.', parsedContent);
      }

      // Walidacja każdej fiszki
      for (let i = 0; i < parsedContent.flashcards.length; i++) {
        const flashcard = parsedContent.flashcards[i];
        
        if (!flashcard || typeof flashcard !== 'object') {
          throw new InvalidResponseError(`Validation failed: flashcard at index ${i} is not a valid object.`, parsedContent);
        }
        
        if (!flashcard.question || typeof flashcard.question !== 'string') {
          throw new InvalidResponseError(`Validation failed: flashcard at index ${i} has missing or invalid question.`, parsedContent);
        }
        
        if (!flashcard.answer || typeof flashcard.answer !== 'string') {
          throw new InvalidResponseError(`Validation failed: flashcard at index ${i} has missing or invalid answer.`, parsedContent);
        }
      }

      // Sprawdzenie czy jest przynajmniej jedna fiszka
      if (parsedContent.flashcards.length === 0) {
        throw new InvalidResponseError('Validation failed: no flashcards generated.', parsedContent);
      }

      return parsedContent;
      
    } catch (error) {
      // Logowanie błędu parsowania (bez wrażliwych danych)
      console.error("Failed to parse or validate API response:", error instanceof Error ? error.message : String(error));
      
      // Jeśli to już nasz custom error, przekaż dalej
      if (error instanceof InvalidResponseError) {
        throw error;
      }
      
      // Inne nieoczekiwane błędy
      throw new InvalidResponseError(
        'Failed to process API response due to unexpected error.', 
        { originalError: error instanceof Error ? error.message : String(error) }
      );
    }
  }
}


================================================
FILE: src/middleware/index.ts
================================================
import { defineMiddleware } from "astro:middleware";

import { createSupabaseServerInstance } from "../db/supabase.client";

// Ścieżki publiczne - dostępne dla wszystkich użytkowników
const PUBLIC_PATHS = [
  // Strony autoryzacji
  "/",
  "/login",
  "/register",
  "/forgot-password",
  "/password-reset",
  // API endpointy autoryzacji
  "/api/auth/login",
  "/api/auth/register",
  "/api/auth/logout",
  "/api/auth/reset-password",
];

// Ścieżki tylko dla niezalogowanych użytkowników
const GUEST_ONLY_PATHS = ["/login", "/register", "/forgot-password"];

export const onRequest = defineMiddleware(async ({ locals, cookies, url, request, redirect }, next) => {
  // Utwórz server-side Supabase client
  const supabase = createSupabaseServerInstance({
    cookies,
    headers: request.headers,
  });

  // Zapisz supabase client w locals dla kompatybilności
  locals.supabase = supabase;

  // Sprawdź czy ścieżka jest publiczna
  const isPublicPath = PUBLIC_PATHS.some((path) => url.pathname === path || url.pathname.startsWith(path));

  // Pobierz dane użytkownika z sesji
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Jeśli użytkownik jest zalogowany, zapisz dane w locals
  if (user) {
    locals.user = {
      email: user.email!,
      id: user.id,
    };

    // Przekieruj zalogowanych użytkowników ze stron tylko dla gości
    if (GUEST_ONLY_PATHS.includes(url.pathname)) {
      return redirect("/dashboard");
    }
  } else if (!isPublicPath) {
    // Przekieruj niezalogowanych użytkowników z chronionych stron
    return redirect("/login");
  }

  return next();
});


================================================
FILE: src/pages/dashboard.astro
================================================
---
import AuthLayout from '../layouts/AuthLayout.astro';
import DashboardView from '../components/views/DashboardView';

export const prerender = false;

// Sprawdź czy użytkownik jest zalogowany (middleware powinien przekierować, ale double-check)
const { user } = Astro.locals;

if (!user) {
  return Astro.redirect('/login');
}
---

<AuthLayout title="Dashboard - Twoje foldery">
  <DashboardView client:load userId={user.id} />
</AuthLayout>


================================================
FILE: src/pages/forgot-password.astro
================================================
---
import GuestLayout from '../layouts/GuestLayout.astro';
import ForgotPasswordForm from '../components/auth/ForgotPasswordForm';
---

<GuestLayout title="Resetuj hasło - 10x Cards Flipper">
  <div class="w-full max-w-md mx-auto">
    <ForgotPasswordForm client:load />
  </div>
</GuestLayout>


================================================
FILE: src/pages/generate.astro
================================================
---
import AuthLayout from '../layouts/AuthLayout.astro';
import GenerateFlashcardsView from '../components/views/GenerateFlashcardsView';

export const prerender = false;

// Sprawdź czy użytkownik jest zalogowany (middleware powinien przekierować, ale double-check)
const { user } = Astro.locals;

if (!user) {
  return Astro.redirect('/login');
}
---

<AuthLayout title="Generuj fiszki z AI">
  <GenerateFlashcardsView client:load userId={user.id} />
</AuthLayout>


================================================
FILE: src/pages/index.astro
================================================
---
import GuestLayout from "../layouts/GuestLayout.astro";
---

<GuestLayout title="10x Cards Flipper - Inteligentne fiszki do nauki">
  <div class="w-full max-w-4xl mx-auto space-y-8 text-center">
    <!-- Hero Section -->
    <div class="space-y-4">
      <h1 class="text-4xl md:text-5xl font-bold text-foreground">
        10x Cards Flipper
      </h1>
      <p class="text-xl text-muted-foreground max-w-2xl mx-auto">
        Inteligentne fiszki do nauki z wykorzystaniem AI. 
        Twórz, organizuj i ucz się efektywniej niż kiedykolwiek.
      </p>
    </div>

    <!-- Features Grid -->
    <div class="grid md:grid-cols-3 gap-6 my-12">
      <div class="space-y-3 p-6 border rounded-lg">
        <div class="text-2xl">🤖</div>
        <h3 class="text-lg font-semibold">Generowanie AI</h3>
        <p class="text-sm text-muted-foreground">
          Automatycznie twórz fiszki z tekstu dzięki sztucznej inteligencji
        </p>
      </div>
      
      <div class="space-y-3 p-6 border rounded-lg">
        <div class="text-2xl">📁</div>
        <h3 class="text-lg font-semibold">Organizacja</h3>
        <p class="text-sm text-muted-foreground">
          Porządkuj fiszki w foldery tematyczne dla lepszej organizacji
        </p>
      </div>
      
      <div class="space-y-3 p-6 border rounded-lg">
        <div class="text-2xl">🎯</div>
        <h3 class="text-lg font-semibold">Efektywna nauka</h3>
        <p class="text-sm text-muted-foreground">
          Ucz się w swoim tempie z intuicyjnym interfejsem
        </p>
      </div>
    </div>

    <!-- CTA Buttons -->
    <div class="flex flex-col sm:flex-row gap-4 justify-center">
      <a href="/register" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground shadow-xs hover:bg-primary/90 h-10 rounded-md px-6 w-full sm:w-auto">
        Rozpocznij za darmo
      </a>
      <a href="/login" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground h-10 rounded-md px-6 w-full sm:w-auto">
        Mam już konto
      </a>
    </div>

    <!-- Additional Info -->
    <div class="text-sm text-muted-foreground mt-8">
      <p>Darmowa rejestracja • Bez limitu fiszek • Natychmiastowy start</p>
    </div>
  </div>
</GuestLayout>



================================================
FILE: src/pages/login.astro
================================================
---
import GuestLayout from '../layouts/GuestLayout.astro';
import LoginForm from '../components/auth/LoginForm';

export const prerender = false;

// Sprawdź czy użytkownik jest już zalogowany
const { user } = Astro.locals;

// Przekieruj zalogowanych użytkowników do dashboardu
if (user) {
  return Astro.redirect('/dashboard');
}
---

<GuestLayout title="Logowanie - 10x Cards Flipper">
  <div class="w-full max-w-md mx-auto">
    <LoginForm client:load />
  </div>
</GuestLayout>


================================================
FILE: src/pages/manual-save.astro
================================================
---
import AuthLayout from '../layouts/AuthLayout.astro';
import ManualSaveView from '../components/views/ManualSaveView';

export const prerender = false;

// Sprawdź czy użytkownik jest zalogowany (middleware powinien przekierować, ale double-check)
const { user } = Astro.locals;

if (!user) {
  return Astro.redirect('/login');
}
---

<AuthLayout title="Ręczne tworzenie fiszek">
  <div class="max-w-2xl mx-auto">
    <div class="flex items-center justify-between mb-8">
      <h1 class="text-3xl font-bold">Ręczne tworzenie fiszek</h1>
      <button 
        class="px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
        onclick="window.location.href = '/dashboard'"
      >
        ← Powrót na pulpit
      </button>
    </div>
    <ManualSaveView client:load userId={user.id} />
  </div>
</AuthLayout>


================================================
FILE: src/pages/password-reset.astro
================================================
---
import GuestLayout from '../layouts/GuestLayout.astro';
import ResetPasswordForm from '../components/auth/ResetPasswordForm';
---

<GuestLayout title="Ustaw nowe hasło - 10x Cards Flipper">
  <div class="w-full max-w-md mx-auto">
    <ResetPasswordForm client:load />
  </div>
</GuestLayout>


================================================
FILE: src/pages/register.astro
================================================
---
import GuestLayout from '../layouts/GuestLayout.astro';
import RegisterForm from '../components/auth/RegisterForm';
---

<GuestLayout title="Rejestracja - 10x Cards Flipper">
  <div class="w-full max-w-md mx-auto">
    <RegisterForm client:load />
  </div>
</GuestLayout>


================================================
FILE: src/pages/users.astro
================================================
---
import Layout from "../layouts/Layout.astro";
import UsersList from "../components/UsersList.tsx";
---

<Layout title="Users - strona użytkowników">
  <main class="min-h-screen bg-gray-50 py-8">
    <div class="container mx-auto px-4">
      <div class="text-center mb-8">
        <h2 class="text-3xl font-bold text-gray-800">Users List</h2>
        <p class="text-gray-600">Below is a list of users fetched from an API.</p>
      </div>

      <UsersList client:load />
    </div>
  </main>
</Layout>



================================================
FILE: src/pages/api/folders.ts
================================================
import type { APIRoute } from "astro";
import { z } from "zod";
import { FolderService } from "../../lib/services/folderService";
import type { CreateFolderCommand } from "../../types";

/**
 * Schema for validating folder creation request
 * Used for POST /api/folders endpoint
 */
const createFolderSchema = z.object({
  name: z
    .string()
    .min(1, "Folder name is required")
    .max(100, "Folder name must not exceed 100 characters")
    .trim()
    .refine(
      (name) => name.length > 0,
      "Folder name cannot be empty or contain only whitespace"
    ),
  user_id: z
    .string()
    .uuid("user_id must be a valid UUID")
    .min(1, "user_id is required"),
});

export const prerender = false;

/**
 * GET /api/folders
 * Endpoint for retrieving paginated list of folders for a specific user
 * 
 * Query Parameters:
 * - user_id (required): UUID of the user to retrieve folders for
 * - page (optional): Page number, defaults to 1
 * - limit (optional): Items per page, defaults to 10, max 50
 * 
 * Response:
 * - 200: Success with folders list (may be empty array) and pagination info
 * - 400: Bad request (invalid parameters)
 * - 500: Internal server error
 */
export const GET: APIRoute = async ({ request, locals }) => {
  try {
    // Parse query parameters from URL
    const url = new URL(request.url);
    const userIdParam = url.searchParams.get('user_id');
    const pageParam = url.searchParams.get('page');
    const limitParam = url.searchParams.get('limit');

    // Validate required user_id parameter
    if (!userIdParam) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Missing required parameter: user_id",
          message: "user_id query parameter is required",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Validate UUID format for user_id
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(userIdParam)) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid user_id format",
          message: "user_id must be a valid UUID",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Parse and validate pagination parameters
    let page = 1;
    let limit = 10;

    if (pageParam) {
      const parsedPage = parseInt(pageParam, 10);
      if (isNaN(parsedPage) || parsedPage < 1) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Invalid page parameter",
            message: "page must be a positive integer greater than 0",
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
      page = parsedPage;
    }

    if (limitParam) {
      const parsedLimit = parseInt(limitParam, 10);
      if (isNaN(parsedLimit) || parsedLimit < 1 || parsedLimit > 50) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Invalid limit parameter",
            message: "limit must be a positive integer between 1 and 50",
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
      limit = parsedLimit;
    }

    // TODO: Add authentication middleware validation
    // For now, we proceed with the provided user_id
    // In future implementation, verify that the authenticated user matches the requested user_id

    // Get Supabase client from locals (following backend rules)
    const supabase = locals.supabase;
    if (!supabase) {
      console.error("Supabase client not available in locals");
      return new Response(
        JSON.stringify({
          success: false,
          error: "Database connection unavailable",
          message: "Internal server configuration error",
        }),
        {
          status: 500,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Initialize folder service
    const folderService = new FolderService(supabase);

    // Retrieve folders for the user
    const result = await folderService.getUserFolders(userIdParam, {
      page,
      limit,
    });

    // Return successful response with folders and pagination
    // Even if no folders are found, return success with empty array
    // This allows frontend to show appropriate "empty state" UI
    return new Response(
      JSON.stringify({
        success: true,
        data: {
          folders: result.folders,
          pagination: result.pagination,
        },
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-cache", // Prevent caching of user-specific data
        },
      }
    );

  } catch (error) {
    console.error("Error in GET /api/folders:", error);

    // Handle specific error types
    if (error instanceof Error) {
      // Database or validation errors
      if (error.message.includes("Invalid user ID format") || 
          error.message.includes("Failed to get folders")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Request processing failed",
            message: error.message,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }

      // Database connection errors
      if (error.message.includes("Failed to retrieve folders from database")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Database error",
            message: "Failed to retrieve folders from database",
          }),
          {
            status: 500,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
    }

    // Generic server error for unhandled cases
    return new Response(
      JSON.stringify({
        success: false,
        error: "Internal server error",
        message: "An unexpected error occurred while processing the request",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
};

/**
 * POST /api/folders
 * Endpoint for creating a new folder for an authenticated user
 * 
 * Request Body:
 * - name (required): String name for the new folder
 * - user_id (required): UUID of the user creating the folder
 * 
 * Headers:
 * - Content-Type: application/json
 * 
 * Response:
 * - 201: Success with created folder data
 * - 400: Bad request (validation errors, duplicate name)
 * - 401: Unauthorized (missing or invalid authentication)
 * - 500: Internal server error
 */
export const POST: APIRoute = async ({ request, locals }) => {
  try {
    // Parse JSON body from request
    let requestBody;
    try {
      requestBody = await request.json();
    } catch (parseError) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid JSON format",
          message: "Request body must be valid JSON",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Validate request body against schema
    const validationResult = createFolderSchema.safeParse(requestBody);
    if (!validationResult.success) {
      const errorMessages = validationResult.error.errors.map(err => err.message);
      return new Response(
        JSON.stringify({
          success: false,
          error: "Validation failed",
          message: errorMessages.join(", "),
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    const { name, user_id } = validationResult.data;

    // Validate user authentication
    // TODO: Implement proper session validation
    if (!user_id) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Authentication required",
          message: "User must be authenticated to create folders",
        }),
        {
          status: 401,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Get Supabase client from locals (following backend rules)
    const supabase = locals.supabase;
    if (!supabase) {
      console.error("Supabase client not available in locals");
      return new Response(
        JSON.stringify({
          success: false,
          error: "Database connection unavailable",
          message: "Internal server configuration error",
        }),
        {
          status: 500,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Initialize folder service
    const folderService = new FolderService(supabase);

    // Create folder data command
    const createFolderCommand: CreateFolderCommand = {
      name: name,
      user_id: user_id,
    };

    // Create the folder
    const newFolder = await folderService.createFolder(createFolderCommand);

    // Return successful response with created folder
    return new Response(
      JSON.stringify({
        success: true,
        data: {
          folder: newFolder,
        },
        message: "Folder created successfully",
      }),
      {
        status: 201,
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-cache", // Prevent caching of user-specific data
        },
      }
    );

  } catch (error) {
    console.error("Error in POST /api/folders:", error);

    // Handle specific error types
    if (error instanceof Error) {
      // Validation or business logic errors
      if (error.message.includes("Invalid user ID format") ||
          error.message.includes("A folder with this name already exists")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Request processing failed",
            message: error.message,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }

      // Database connection errors
      if (error.message.includes("Failed to create folder in database") ||
          error.message.includes("Failed to validate folder uniqueness")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Database error",
            message: "Failed to process folder creation",
          }),
          {
            status: 500,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
    }

    // Generic server error for unhandled cases
    return new Response(
      JSON.stringify({
        success: false,
        error: "Internal server error",
        message: "An unexpected error occurred while processing the request",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
};


================================================
FILE: src/pages/api/users.ts
================================================
import type { APIRoute } from "astro";

export const prerender = false;

interface User {
  id: number;
  name: string;
  email: string;
  phone: string;
  website: string;
  company: {
    name: string;
  };
  address: {
    city: string;
    street: string;
  };
}

// Dummy users data
const dummyUsers: User[] = [
  {
    id: 1,
    name: "Jan Kowalski",
    email: "jan.kowalski@example.com",
    phone: "+48 123 456 789",
    website: "jankowalski.pl",
    company: {
      name: "Tech Solutions",
    },
    address: {
      city: "Warszawa",
      street: "ul. Piękna 15",
    },
  },
  {
    id: 2,
    name: "Anna Nowak",
    email: "anna.nowak@example.com",
    phone: "+48 987 654 321",
    website: "annanowak.dev",
    company: {
      name: "Digital Agency",
    },
    address: {
      city: "Kraków",
      street: "ul. Floriańska 3",
    },
  },
  {
    id: 3,
    name: "Piotr Wiśniewski",
    email: "piotr.wisniewski@example.com",
    phone: "+48 555 666 777",
    website: "piotrw.com",
    company: {
      name: "StartupLab",
    },
    address: {
      city: "Gdańsk",
      street: "ul. Długa 22",
    },
  },
  {
    id: 4,
    name: "Maria Wójcik",
    email: "maria.wojcik@example.com",
    phone: "+48 444 333 222",
    website: "mariawojcik.net",
    company: {
      name: "Creative Studio",
    },
    address: {
      city: "Wrocław",
      street: "ul. Świdnicka 8",
    },
  },
  {
    id: 5,
    name: "Tomasz Kamiński",
    email: "tomasz.kaminski@example.com",
    phone: "+48 111 222 333",
    website: "tomaszk.io",
    company: {
      name: "Code Masters",
    },
    address: {
      city: "Poznań",
      street: "ul. Stary Rynek 1",
    },
  },
  {
    id: 6,
    name: "Katarzyna Lewandowska",
    email: "katarzyna.lewandowska@example.com",
    phone: "+48 888 999 000",
    website: "katarzyna-dev.pl",
    company: {
      name: "Innovation Hub",
    },
    address: {
      city: "Łódź",
      street: "ul. Piotrkowska 104",
    },
  },
  {
    id: 7,
    name: "Michał Zieliński",
    email: "michal.zielinski@example.com",
    phone: "+48 777 888 999",
    website: "michalz.tech",
    company: {
      name: "Web Solutions",
    },
    address: {
      city: "Katowice",
      street: "ul. Mariacka 17",
    },
  },
  {
    id: 8,
    name: "Agnieszka Szymańska",
    email: "agnieszka.szymanska@example.com",
    phone: "+48 666 777 888",
    website: "agaszymania.com",
    company: {
      name: "Design Studio",
    },
    address: {
      city: "Bydgoszcz",
      street: "ul. Gdańska 25",
    },
  },
];

// GET endpoint - pobieranie wszystkich użytkowników
export const GET: APIRoute = async ({ request }) => {
  try {
    // Symulacja opóźnienia serwera (opcjonalne)
    await new Promise((resolve) => setTimeout(resolve, 500));

    let users = [...dummyUsers];

    return new Response(
      JSON.stringify({
        success: true,
        data: users,
        total: dummyUsers.length,
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-cache",
        },
      }
    );
  } catch (error) {
    console.error("Error in GET /api/users:", error);

    return new Response(
      JSON.stringify({
        success: false,
        error: "Nie udało się pobrać użytkowników",
        message: error instanceof Error ? error.message : "Unknown error",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
};



================================================
FILE: src/pages/api/auth/login.ts
================================================
import type { APIRoute } from "astro";
import { z } from "zod";
import { createSupabaseServerInstance } from "../../../db/supabase.client";

// Schema walidacji dla żądania logowania
const loginSchema = z.object({
  email: z.string().email({ message: "Nieprawidłowy format adresu email" }),
  password: z.string().min(1, { message: "Hasło jest wymagane" }),
});

export const prerender = false;

export const POST: APIRoute = async ({ request, cookies }) => {
  try {
    // Parsuj i waliduj dane wejściowe
    const body = await request.json();
    const validationResult = loginSchema.safeParse(body);

    if (!validationResult.success) {
      return new Response(
        JSON.stringify({
          error: validationResult.error.errors[0].message,
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        },
      );
    }

    const { email, password } = validationResult.data;

    // Utwórz server-side Supabase client
    const supabase = createSupabaseServerInstance({
      cookies,
      headers: request.headers,
    });

    // Zaloguj użytkownika
    const { data, error } = await supabase.auth.signInWithPassword({
      email: email.trim(),
      password,
    });

    if (error) {
      return new Response(
        JSON.stringify({
          error: error.message === "Invalid login credentials"
            ? "Nieprawidłowy email lub hasło"
            : error.message,
        }),
        {
          status: 401,
          headers: {
            "Content-Type": "application/json",
          },
        },
      );
    }

    // Zwróć dane użytkownika
    return new Response(
      JSON.stringify({
        user: {
          id: data.user.id,
          email: data.user.email,
        },
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  } catch (error) {
    console.error("Login error:", error);
    return new Response(
      JSON.stringify({
        error: "Wystąpił błąd podczas logowania",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  }
};



================================================
FILE: src/pages/api/auth/logout.ts
================================================
import type { APIRoute } from "astro";
import { createSupabaseServerInstance } from "../../../db/supabase.client";

export const prerender = false;

export const POST: APIRoute = async ({ cookies, request }) => {
  try {
    // Utwórz server-side Supabase client
    const supabase = createSupabaseServerInstance({
      cookies,
      headers: request.headers,
    });

    // Wyloguj użytkownika
    const { error } = await supabase.auth.signOut();

    if (error) {
      return new Response(
        JSON.stringify({
          error: error.message,
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        },
      );
    }

    return new Response(null, { 
      status: 204 
    });
  } catch (error) {
    console.error("Logout error:", error);
    return new Response(
      JSON.stringify({
        error: "Wystąpił błąd podczas wylogowania",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  }
};



================================================
FILE: src/pages/api/auth/register.ts
================================================
import type { APIRoute } from "astro";
import { z } from "zod";
import { createSupabaseServerInstance } from "../../../db/supabase.client";

// Schema walidacji dla żądania rejestracji
const registerSchema = z
  .object({
    email: z
      .string()
      .min(1, { message: "Email jest wymagany" })
      .email({ message: "Wprowadź poprawny adres email" }),
    password: z
      .string()
      .min(8, { message: "Hasło musi mieć minimum 8 znaków" })
      .regex(/[A-Z]/, { message: "Hasło musi zawierać co najmniej jedną wielką literę" })
      .regex(/[0-9]/, { message: "Hasło musi zawierać co najmniej jedną cyfrę" })
      .regex(/[!@#$%^&*(),.?":{}|<>]/, {
        message: "Hasło musi zawierać co najmniej jeden znak specjalny",
      }),
    confirmPassword: z.string().min(1, { message: "Potwierdzenie hasła jest wymagane" }),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Hasła muszą być identyczne",
    path: ["confirmPassword"],
  });

export const prerender = false;

export const POST: APIRoute = async ({ request, cookies }) => {
  try {
    // Parsuj i waliduj dane wejściowe
    const body = await request.json();
    const validationResult = registerSchema.safeParse(body);

    if (!validationResult.success) {
      // Zwróć pierwszy błąd walidacji
      return new Response(
        JSON.stringify({
          error: validationResult.error.errors[0].message,
          field: validationResult.error.errors[0].path[0],
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        },
      );
    }

    const { email, password } = validationResult.data;

    // Utwórz server-side Supabase client
    const supabase = createSupabaseServerInstance({
      cookies,
      headers: request.headers,
    });

    // Zarejestruj użytkownika
    const { data, error } = await supabase.auth.signUp({
      email: email.trim(),
      password,
      options: {
        // Email confirmation wyłączone - użytkownik może od razu korzystać z aplikacji
        emailRedirectTo: undefined,
      },
    });

    if (error) {
      // Obsługa specyficznych błędów Supabase
      let errorMessage = "Wystąpił błąd podczas rejestracji";

      if (error.message.includes("already registered")) {
        errorMessage = "Ten adres email jest już zarejestrowany";
      } else if (error.message.includes("Password")) {
        errorMessage = "Hasło nie spełnia wymagań bezpieczeństwa";
      } else if (error.message.includes("Email")) {
        errorMessage = "Nieprawidłowy adres email";
      }

      return new Response(
        JSON.stringify({
          error: errorMessage,
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        },
      );
    }

    // Sprawdź czy użytkownik został utworzony i automatycznie zalogowany
    if (!data.user || !data.session) {
      return new Response(
        JSON.stringify({
          error: "Nie udało się utworzyć konta. Spróbuj ponownie.",
        }),
        {
          status: 500,
          headers: {
            "Content-Type": "application/json",
          },
        },
      );
    }

    // Zwróć dane użytkownika i sukces
    return new Response(
      JSON.stringify({
        success: true,
        user: {
          id: data.user.id,
          email: data.user.email,
        },
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  } catch (error) {
    console.error("Registration error:", error);
    return new Response(
      JSON.stringify({
        error: "Wystąpił nieoczekiwany błąd. Spróbuj ponownie później.",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  }
};



================================================
FILE: src/pages/api/flashcards/[flashcardId].ts
================================================
import type { APIRoute } from "astro";
import { z } from "zod";
import type { FlashcardDTO, UpdateFlashcardCommand } from "../../../types";
import { supabaseClient } from "../../../db/supabase.client";
import { FlashcardGenerationService } from "../../../lib/services/flashcardService";

export const prerender = false;

// Zod schema for UUID validation
const FlashcardIdSchema = z.string().uuid("Flashcard ID must be a valid UUID");

// Zod schema for PUT request validation
const UpdateFlashcardSchema = z.object({
  front: z
    .string()
    .min(1, "Front text cannot be empty")
    .max(200, "Front text cannot exceed 200 characters")
    .trim(),
  back: z
    .string()
    .min(1, "Back text cannot be empty")
    .max(500, "Back text cannot exceed 500 characters")
    .trim(),
  folder_id: z
    .string()
    .uuid("Folder ID must be a valid UUID")
    .optional(),
  generation_source: z
    .enum(["manual", "ai"], {
      errorMap: () => ({ message: "Generation source must be either 'manual' or 'ai'" })
    }),
});

/**
 * GET endpoint /api/flashcards/{flashcardId} - get flashcard details
 * Returns detailed information about a specific flashcard by ID
 */
export const GET: APIRoute = async ({ params, locals }) => {
  try {
    // Extract and validate flashcard ID from URL parameters
    const { flashcardId } = params;
    
    if (!flashcardId) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Missing parameter",
          message: "Flashcard ID is required",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Validate UUID format
    let validatedFlashcardId: string;
    try {
      validatedFlashcardId = FlashcardIdSchema.parse(flashcardId);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Invalid parameter",
            message: "Flashcard ID must be a valid UUID",
            details: error.errors,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
      
      return new Response(
        JSON.stringify({
          success: false,
          error: "Validation error",
          message: "Failed to validate flashcard ID",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // TODO: Add authentication and authorization logic
    const userId = locals.user?.id;
    
    if (!userId) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Unauthorized",
          message: "User must be authenticated",
        }),
        {
          status: 401,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Initialize the flashcard service
    const flashcardService = new FlashcardGenerationService(supabaseClient);

    // Get the flashcard using the service
    const flashcardData = await flashcardService.getFlashcardById(validatedFlashcardId, userId);

    // Handle not found case
    if (!flashcardData) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Not found",
          message: "Flashcard not found or access denied",
        }),
        {
          status: 404,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Return successful response
    return new Response(
      JSON.stringify({
        success: true,
        data: flashcardData,
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

  } catch (error) {
    console.error("Error in GET /api/flashcards/[flashcardId]:", error);

    return new Response(
      JSON.stringify({
        success: false,
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error occurred",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
};

/**
 * PUT endpoint /api/flashcards/{flashcardId} - update an existing flashcard
 * Updates front, back, generation_source, and optionally folder_id of a flashcard
 */
export const PUT: APIRoute = async ({ params, request, locals }) => {
  try {
    // Extract and validate flashcard ID from URL parameters
    const { flashcardId } = params;
    
    if (!flashcardId) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Missing parameter",
          message: "Flashcard ID is required",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Validate UUID format for flashcard ID
    let validatedFlashcardId: string;
    try {
      validatedFlashcardId = FlashcardIdSchema.parse(flashcardId);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Invalid parameter",
            message: "Flashcard ID must be a valid UUID",
            details: error.errors,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
      
      return new Response(
        JSON.stringify({
          success: false,
          error: "Validation error",
          message: "Failed to validate flashcard ID",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Parse and validate request body
    let requestData: UpdateFlashcardCommand;
    
    try {
      const body = await request.json();
      requestData = UpdateFlashcardSchema.parse(body);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Validation failed",
            message: error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(", "),
            details: error.errors,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
      
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid request body",
          message: "Failed to parse JSON or invalid data format",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // TODO: Add authentication and authorization logic
    const userId = locals.user?.id;
    
    if (!userId) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Unauthorized",
          message: "User must be authenticated",
        }),
        {
          status: 401,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Initialize the flashcard service
    const flashcardService = new FlashcardGenerationService(supabaseClient);

    // Update the flashcard using the service
    const updatedFlashcard = await flashcardService.updateFlashcard(
      validatedFlashcardId, 
      requestData, 
      userId
    );

    // Return successful response
    return new Response(
      JSON.stringify({
        success: true,
        data: updatedFlashcard,
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

  } catch (error) {
    console.error("Error in PUT /api/flashcards/[flashcardId]:", error);

    // Handle specific business logic errors
    if (error instanceof Error) {
      if (error.message.includes("Flashcard not found")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Not found",
            message: "Flashcard not found or access denied",
          }),
          {
            status: 404,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }

      if (error.message.includes("Folder not found")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Not found",
            message: "Folder not found or access denied",
          }),
          {
            status: 404,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }

      if (error.message.includes("access denied") || error.message.includes("unauthorized")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Unauthorized",
            message: "You don't have permission to update this flashcard",
          }),
          {
            status: 401,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
    }

    return new Response(
      JSON.stringify({
        success: false,
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error occurred",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
};

/**
 * DELETE endpoint /api/flashcards/{flashcardId} - delete a flashcard
 * Removes a specific flashcard by ID after verifying ownership
 */
export const DELETE: APIRoute = async ({ params, locals }) => {
  try {
    // Extract and validate flashcard ID from URL parameters
    const { flashcardId } = params;
    
    if (!flashcardId) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Missing parameter",
          message: "Flashcard ID is required",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Validate UUID format
    let validatedFlashcardId: string;
    try {
      validatedFlashcardId = FlashcardIdSchema.parse(flashcardId);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Invalid parameter",
            message: "Flashcard ID must be a valid UUID",
            details: error.errors,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
      
      return new Response(
        JSON.stringify({
          success: false,
          error: "Validation error",
          message: "Failed to validate flashcard ID",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // TODO: Add authentication and authorization logic
    const userId = locals.user?.id;
    
    if (!userId) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Unauthorized",
          message: "User must be authenticated",
        }),
        {
          status: 401,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Initialize the flashcard service
    const flashcardService = new FlashcardGenerationService(supabaseClient);

    // Delete the flashcard using the service
    await flashcardService.deleteFlashcard(validatedFlashcardId, userId);

    // Return successful response
    return new Response(
      JSON.stringify({
        success: true,
        message: "Flashcard deleted successfully",
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

  } catch (error) {
    console.error("Error in DELETE /api/flashcards/[flashcardId]:", error);

    // Handle specific business logic errors
    if (error instanceof Error) {
      if (error.message.includes("Flashcard not found") || error.message.includes("access denied")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Not found",
            message: "Flashcard not found or access denied",
          }),
          {
            status: 404,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }

      if (error.message.includes("unauthorized")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Unauthorized",
            message: "You don't have permission to delete this flashcard",
          }),
          {
            status: 401,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
    }

    return new Response(
      JSON.stringify({
        success: false,
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error occurred",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
};


================================================
FILE: src/pages/api/flashcards/bulk-save.ts
================================================
 import type { APIRoute } from "astro";
import { z } from "zod";
import type { BulkSaveFlashcardsCommand } from "../../../types";
import { FlashcardGenerationService } from "../../../lib/services/flashcardService";

export const prerender = false;

// Zod schema for individual flashcard validation in bulk save
const FlashcardItemSchema = z.object({
  front: z
    .string()
    .min(1, "Front text cannot be empty")
    .max(200, "Front text cannot exceed 200 characters")
    .trim(),
  back: z
    .string()
    .min(1, "Back text cannot be empty")
    .max(500, "Back text cannot exceed 500 characters")
    .trim(),
  generation_source: z
    .literal("ai", {
      errorMap: () => ({ message: "Generation source must be 'ai' for bulk save operations" })
    }),
});

// Zod schema for POST request validation - bulk save
const BulkSaveFlashcardsSchema = z.object({
  folder_id: z
    .string()
    .uuid("Folder ID must be a valid UUID"),
  flashcards: z
    .array(FlashcardItemSchema)
    .min(1, "At least one flashcard must be provided")
    .max(50, "Cannot save more than 50 flashcards at once"), // Performance limit
});

// Response type for bulk save operation
interface BulkSaveResponse {
  success: boolean;
  message: string;
  saved_count: number;
  flashcard_ids: string[];
}

/**
 * POST endpoint /api/flashcards/bulk-save - save multiple flashcards to a folder
 * Used primarily for saving AI-generated flashcards that user has accepted
 */
export const POST: APIRoute = async ({ request, locals }) => {
  try {
    // Get Supabase client from context
    const supabase = locals.supabase;
    if (!supabase) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Internal server error",
          message: "Database connection not available",
        }),
        {
          status: 500,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Parse and validate request body
    let requestData: BulkSaveFlashcardsCommand;
    
    try {
      const body = await request.json();
      requestData = BulkSaveFlashcardsSchema.parse(body);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Validation failed",
            message: error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(", "),
            details: error.errors,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
      
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid request body",
          message: "Failed to parse JSON or invalid data format",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Get user ID from session (set by middleware)
    const userId = locals.user?.id;
    
    if (!userId) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Unauthorized",
          message: "User must be authenticated",
        }),
        {
          status: 401,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }
    
    console.log("Bulk save request for user ID:", userId);

    // Verify that the folder exists and belongs to the user (authorization check)
    const { data: folderData, error: folderError } = await supabase
      .from('folders')
      .select('id, user_id, name')
      .eq('id', requestData.folder_id)
      .eq('user_id', userId)
      .single();

    if (folderError) {
      if (folderError.code === 'PGRST116') { // PostgREST "no rows returned" error
        return new Response(
          JSON.stringify({
            success: false,
            error: "Not found",
            message: "Folder not found or access denied",
          }),
          {
            status: 404,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
      
      console.error("Database error fetching folder for authorization:", folderError);
      return new Response(
        JSON.stringify({
          success: false,
          error: "Internal server error",
          message: "Failed to verify folder access",
        }),
        {
          status: 500,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    if (!folderData) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Not found",
          message: "Folder not found or access denied",
        }),
        {
          status: 404,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Initialize the flashcard service with the Supabase client from context
    const flashcardService = new FlashcardGenerationService(supabase);

    // Delegate bulk save operation to service layer
    const result = await flashcardService.bulkSaveFlashcards(requestData, userId);

    return new Response(
      JSON.stringify({
        success: true,
        message: result.message,
        saved_count: result.saved_count,
        flashcard_ids: result.flashcard_ids,
      }),
      {
        status: 201,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

  } catch (error) {
    console.error("Error in POST /api/flashcards/bulk-save:", error);

    // Handle specific business logic errors
    if (error instanceof Error) {
      if (error.message.includes("Folder not found")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Not found",
            message: "Folder not found or access denied",
          }),
          {
            status: 404,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }

      if (error.message.includes("access denied")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Unauthorized",
            message: "Access denied to the specified folder",
          }),
          {
            status: 401,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
    }

    return new Response(
      JSON.stringify({
        success: false,
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error occurred",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
};


================================================
FILE: src/pages/api/flashcards/generate.ts
================================================
import type { APIRoute } from "astro";
import { z } from "zod";
import type { GenerateFlashcardsCommand, GenerateFlashcardsResponseDTO } from "../../../types";
import { FlashcardGenerationService } from "../../../lib/services/flashcardService";
import { OpenRouterService } from "../../../lib/services/openRouterService";
import { supabaseClient } from "../../../db/supabase.client";

export const prerender = false;

// Zod schema for input validation
const GenerateFlashcardsSchema = z.object({
  text: z
    .string()
    .min(1, "Text cannot be empty")
    .max(5000, "Text cannot exceed 5000 characters")
    .trim()
});

// POST endpoint /api/flashcards/generate - generate flashcards from text input
export const POST: APIRoute = async ({ request }) => {
  try {
    // Parse and validate request body
    let requestData: GenerateFlashcardsCommand;
    
    try {
      const body = await request.json();
      requestData = GenerateFlashcardsSchema.parse(body);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Validation failed",
            message: error.errors.map(e => e.message).join(", "),
            details: error.errors,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
      
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid request body",
          message: "Failed to parse JSON or invalid data format",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Initialize the OpenRouter service for AI generation
    const openRouterService = new OpenRouterService();
    
    // Model name from environment variables
    const modelName = import.meta.env.AI_MODELNAME || "openai/gpt-4o-mini";
    
    // Generate flashcards using OpenRouter AI
    const aiResult = await openRouterService.generateFlashcards(requestData.text, modelName);
    
    // Transform AI result to match expected response format
    const result: GenerateFlashcardsResponseDTO = {
      suggested_folder_name: aiResult.title,
      flashcards_proposals: aiResult.flashcards.map(flashcard => ({
        front: flashcard.question,
        back: flashcard.answer,
        generation_source: 'ai' as const
      }))
    };

    return new Response(
      JSON.stringify({
        success: true,
        data: result,
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-cache",
        },
      }
    );

  } catch (error) {
    console.error("Error in POST /api/flashcards/generate:", error);

    // Obsługa specyficznych błędów z OpenRouter Service
    if (error instanceof Error) {
      // Błędy konfiguracji
      if (error.message.includes('OPENROUTER_API_KEY')) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Configuration error",
            message: "Service is not properly configured. Please contact administrator.",
          }),
          {
            status: 500,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
      
      // Błędy walidacji parametrów
      if (error.message.includes('cannot be empty')) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Validation error",
            message: error.message,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
    }

    return new Response(
      JSON.stringify({
        success: false,
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error occurred",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
};


================================================
FILE: src/pages/api/flashcards/index.ts
================================================
import type { APIRoute } from "astro";
import { z } from "zod";
import type { CreateFlashcardCommand, FlashcardDTO } from "../../../types";
import { supabaseClient } from "../../../db/supabase.client";
import { FlashcardGenerationService } from "../../../lib/services/flashcardService";

export const prerender = false;

// Zod schema for POST request validation
const CreateFlashcardSchema = z.object({
  front: z
    .string()
    .min(1, "Front text cannot be empty")
    .max(200, "Front text cannot exceed 200 characters")
    .trim(),
  back: z
    .string()
    .min(1, "Back text cannot be empty")
    .max(500, "Back text cannot exceed 500 characters")
    .trim(),
  folder_id: z
    .string()
    .uuid("Folder ID must be a valid UUID"),
  generation_source: z
    .enum(["manual", "ai"], {
      errorMap: () => ({ message: "Generation source must be either 'manual' or 'ai'" })
    }),
});

// Zod schema for GET request query parameters validation
const GetFlashcardsQuerySchema = z.object({
  folderId: z
    .string()
    .uuid("Folder ID must be a valid UUID")
    .optional(),
  page: z
    .string()
    .regex(/^\d+$/, "Page must be a positive integer")
    .transform(val => parseInt(val, 10))
    .refine(val => val > 0, "Page must be greater than 0")
    .default("1"),
  limit: z
    .string()
    .regex(/^\d+$/, "Limit must be a positive integer")
    .transform(val => parseInt(val, 10))
    .refine(val => val > 0 && val <= 100, "Limit must be between 1 and 100")
    .default("10"),
  sortBy: z
    .enum(["created_at", "updated_at", "front", "back"], {
      errorMap: () => ({ message: "Sort by must be one of: created_at, updated_at, front, back" })
    })
    .default("created_at"),
  order: z
    .enum(["asc", "desc"], {
      errorMap: () => ({ message: "Order must be either 'asc' or 'desc'" })
    })
    .default("desc"),
});

// Response type for GET flashcards
interface GetFlashcardsResponse {
  flashcards: FlashcardDTO[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// GET endpoint /api/flashcards - list flashcards with pagination and filtering
export const GET: APIRoute = async ({ request, locals }) => {
  try {
    // Parse and validate query parameters
    const url = new URL(request.url);
    const queryParams = Object.fromEntries(url.searchParams.entries());
    
    let validatedParams;
    try {
      validatedParams = GetFlashcardsQuerySchema.parse(queryParams);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Validation failed",
            message: error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(", "),
            details: error.errors,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
      
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid query parameters",
          message: "Failed to parse query parameters",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }
    
    // TODO: Add authentication and authorization logic
    const userId = locals.user?.id;
    
    if (!userId) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Unauthorized",
          message: "User must be authenticated",
        }),
        {
          status: 401,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Initialize the flashcard service
    const flashcardService = new FlashcardGenerationService(supabaseClient);

    // Get flashcards using the service
    const result = await flashcardService.getFlashcards(userId, {
      folderId: validatedParams.folderId,
      page: validatedParams.page,
      limit: validatedParams.limit,
      sortBy: validatedParams.sortBy,
      order: validatedParams.order,
    });

    // Return successful response
    return new Response(
      JSON.stringify({
        success: true,
        data: result,
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

  } catch (error) {
    console.error("Error in GET /api/flashcards:", error);

    // Handle specific business logic errors
    if (error instanceof Error && error.message.includes("Folder not found")) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Not found",
          message: "Folder not found or access denied",
        }),
        {
          status: 404,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    return new Response(
      JSON.stringify({
        success: false,
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error occurred",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
};

// POST endpoint /api/flashcards - create a new flashcard
export const POST: APIRoute = async ({ request, locals }) => {
  try {
    // Parse and validate request body
    let requestData: CreateFlashcardCommand;
    
    try {
      const body = await request.json();
      requestData = CreateFlashcardSchema.parse(body);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Validation failed",
            message: error.errors.map(e => e.message).join(", "),
            details: error.errors,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
      
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid request body",
          message: "Failed to parse JSON or invalid data format",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // TODO: Add authentication and authorization logic
    const userId = locals.user?.id;
    
    if (!userId) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Unauthorized",
          message: "User must be authenticated",
        }),
        {
          status: 401,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }
    
    console.log("Using user ID:", userId);
    // Initialize the flashcard service
    const flashcardService = new FlashcardGenerationService(supabaseClient);

    // Create the flashcard using the service
    const createdFlashcard = await flashcardService.createFlashcard(requestData, userId);
    return new Response(
      JSON.stringify({
        success: true,
        data: createdFlashcard,
      }),
      {
        status: 201,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

  } catch (error) {
    console.error("Error in POST /api/flashcards:", error);

    return new Response(
      JSON.stringify({
        success: false,
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error occurred",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
};


================================================
FILE: src/pages/api/folders/[folderId].ts
================================================
import type { APIRoute } from "astro";
import { FolderService } from "../../../lib/services/folderService";
import type { UpdateFolderCommand } from "../../../types";
import { z } from "zod";

export const prerender = false;

// Zod schema for validating UUID format
const uuidSchema = z.string().uuid("Must be a valid UUID");

// Zod schema for validating update folder request body
const updateFolderSchema = z.object({
  name: z.string()
    .trim()
    .min(1, "Folder name cannot be empty")
    .max(100, "Folder name cannot exceed 100 characters"),
});

/**
 * GET /api/folders/{folderId}
 * Endpoint for retrieving detailed information about a specific folder
 * 
 * Path Parameters:
 * - folderId: UUID of the folder to retrieve
 * 
 * Query Parameters:
 * - user_id (required): UUID of the user who owns the folder
 * 
 * Response:
 * - 200: Success with folder details including flashcard count
 * - 400: Bad request (invalid parameters)
 * - 404: Folder not found or not owned by user
 * - 500: Internal server error
 */
export const GET: APIRoute = async ({ params, request, locals }) => {
  try {
    // Extract folderId from path parameters
    const { folderId } = params;
    
    // Parse query parameters from URL
    const url = new URL(request.url);
    const userIdParam = url.searchParams.get('user_id');

    // Validate required parameters
    if (!folderId) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Missing required parameter: folderId",
          message: "folderId path parameter is required",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    if (!userIdParam) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Missing required parameter: user_id",
          message: "user_id query parameter is required",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Validate UUID format for both parameters
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    
    if (!uuidRegex.test(folderId)) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid folderId format",
          message: "folderId must be a valid UUID",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    if (!uuidRegex.test(userIdParam)) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid user_id format",
          message: "user_id must be a valid UUID",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // TODO: Add authentication middleware validation
    // For now, we proceed with the provided user_id
    // In future implementation, verify that the authenticated user matches the requested user_id

    // Get Supabase client from locals (following backend rules)
    const supabase = locals.supabase;
    if (!supabase) {
      console.error("Supabase client not available in locals");
      return new Response(
        JSON.stringify({
          success: false,
          error: "Database connection unavailable",
          message: "Internal server configuration error",
        }),
        {
          status: 500,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Initialize folder service
    const folderService = new FolderService(supabase);

    // Retrieve folder details with flashcard count
    const folderDetails = await folderService.getFolderDetails(folderId, userIdParam);

    // Return successful response with folder details
    return new Response(
      JSON.stringify({
        success: true,
        data: folderDetails,
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-cache", // Prevent caching of user-specific data
        },
      }
    );

  } catch (error) {
    console.error("Error in GET /api/folders/[folderId]:", error);

    // Handle specific error types
    if (error instanceof Error) {
      // Folder not found or access denied
      if (error.message.includes("Folder not found") || 
          error.message.includes("Access denied")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Folder not found",
            message: error.message,
          }),
          {
            status: 404,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }

      // Database or validation errors
      if (error.message.includes("Invalid") || 
          error.message.includes("Failed to get folder")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Request processing failed",
            message: error.message,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }

      // Database connection errors
      if (error.message.includes("Failed to retrieve") || 
          error.message.includes("Database error")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Database error",
            message: "Failed to retrieve folder details from database",
          }),
          {
            status: 500,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
    }

    // Generic server error for unhandled cases
    return new Response(
      JSON.stringify({
        success: false,
        error: "Internal server error",
        message: "An unexpected error occurred while processing the request",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
};

/**
 * PUT /api/folders/{folderId}
 * Endpoint for updating a folder's name
 * 
 * Path Parameters:
 * - folderId: UUID of the folder to update
 * 
 * Query Parameters:
 * - user_id (required): UUID of the user who owns the folder
 * 
 * Request Body:
 * - name (required): New name for the folder
 * 
 * Response:
 * - 200: Success with updated folder details
 * - 400: Bad request (invalid parameters, empty name, or duplicate name)
 * - 404: Folder not found or not owned by user
 * - 500: Internal server error
 */
export const PUT: APIRoute = async ({ params, request, locals }) => {
  try {
    // Extract folderId from path parameters
    const { folderId } = params;
    
    // Parse query parameters from URL
    const url = new URL(request.url);
    const userIdParam = url.searchParams.get('user_id');

    // Parse request body
    let requestBody: any;
    try {
      const textBody = await request.text();
      if (!textBody) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Missing request body",
            message: "Request body with folder name is required",
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
      requestBody = JSON.parse(textBody);
    } catch (parseError) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid JSON format",
          message: "Request body must be valid JSON",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Validate required parameters
    if (!folderId) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Missing required parameter: folderId",
          message: "folderId path parameter is required",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    if (!userIdParam) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Missing required parameter: user_id",
          message: "user_id query parameter is required",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Validate request body structure
    if (!requestBody || typeof requestBody !== 'object') {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid request body",
          message: "Request body must be a valid object",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Validate UUID format for both parameters using Zod
    const folderIdValidation = uuidSchema.safeParse(folderId);
    if (!folderIdValidation.success) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid folderId format",
          message: folderIdValidation.error.errors[0].message,
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    const userIdValidation = uuidSchema.safeParse(userIdParam);
    if (!userIdValidation.success) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid user_id format",
          message: userIdValidation.error.errors[0].message,
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Validate request body using Zod schema
    const bodyValidation = updateFolderSchema.safeParse(requestBody);
    if (!bodyValidation.success) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Validation error",
          message: bodyValidation.error.errors[0].message,
          details: bodyValidation.error.errors,
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // TODO: Add authentication middleware validation
    // For now, we proceed with the provided user_id
    // In future implementation, verify that the authenticated user matches the requested user_id

    // Get Supabase client from locals (following backend rules)
    const supabase = locals.supabase;
    if (!supabase) {
      console.error("Supabase client not available in locals");
      return new Response(
        JSON.stringify({
          success: false,
          error: "Database connection unavailable",
          message: "Internal server configuration error",
        }),
        {
          status: 500,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Initialize folder service
    const folderService = new FolderService(supabase);

    // Create update command with validated data
    const updateCommand: UpdateFolderCommand = {
      name: bodyValidation.data.name, // Use validated and trimmed data from Zod
    };

    // Update the folder
    const updatedFolder = await folderService.updateFolder(folderId, userIdParam, updateCommand);

    // Return successful response with updated folder details
    return new Response(
      JSON.stringify({
        success: true,
        data: updatedFolder,
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-cache", // Prevent caching of user-specific data
        },
      }
    );

  } catch (error) {
    console.error("Error in PUT /api/folders/[folderId]:", error);

    // Handle specific error types
    if (error instanceof Error) {
      // Folder not found or access denied
      if (error.message.includes("Folder not found") || 
          error.message.includes("Access denied")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Folder not found",
            message: error.message,
          }),
          {
            status: 404,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }

      // Validation errors and duplicate name errors
      if (error.message.includes("Invalid") || 
          error.message.includes("already exists") ||
          error.message.includes("cannot be empty") ||
          error.message.includes("Failed to validate")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Validation error",
            message: error.message,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }

      // Database connection errors
      if (error.message.includes("Failed to update") || 
          error.message.includes("Database error")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Database error",
            message: "Failed to update folder in database",
          }),
          {
            status: 500,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
    }

    // Generic server error for unhandled cases
    return new Response(
      JSON.stringify({
        success: false,
        error: "Internal server error",
        message: "An unexpected error occurred while processing the request",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
};

/**
 * DELETE /api/folders/{folderId}
 * Endpoint for deleting a folder and all associated flashcards (cascade delete)
 * 
 * Path Parameters:
 * - folderId: UUID of the folder to delete
 * 
 * Query Parameters:
 * - user_id (required): UUID of the user who owns the folder
 * 
 * Response:
 * - 200: Success with confirmation message
 * - 400: Bad request (invalid parameters)
 * - 404: Folder not found or not owned by user
 * - 500: Internal server error
 */
export const DELETE: APIRoute = async ({ params, request, locals }) => {
  try {
    // Extract folderId from path parameters
    const { folderId } = params;
    
    // Parse query parameters from URL
    const url = new URL(request.url);
    const userIdParam = url.searchParams.get('user_id');

    // Validate required parameters
    if (!folderId) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Missing required parameter: folderId",
          message: "folderId path parameter is required",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    if (!userIdParam) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Missing required parameter: user_id",
          message: "user_id query parameter is required",
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Validate UUID format for both parameters using Zod
    const folderIdValidation = uuidSchema.safeParse(folderId);
    if (!folderIdValidation.success) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid folderId format",
          message: folderIdValidation.error.errors[0].message,
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    const userIdValidation = uuidSchema.safeParse(userIdParam);
    if (!userIdValidation.success) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Invalid user_id format",
          message: userIdValidation.error.errors[0].message,
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // TODO: Add authentication middleware validation
    // For now, we proceed with the provided user_id
    // In future implementation, verify that the authenticated user matches the requested user_id

    // Get Supabase client from locals (following backend rules)
    const supabase = locals.supabase;
    if (!supabase) {
      console.error("Supabase client not available in locals");
      return new Response(
        JSON.stringify({
          success: false,
          error: "Database connection unavailable",
          message: "Internal server configuration error",
        }),
        {
          status: 500,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    // Initialize folder service
    const folderService = new FolderService(supabase);

    // Delete the folder (and associated flashcards via cascade)
    await folderService.deleteFolder(folderId, userIdParam);

    // Return successful response with confirmation
    return new Response(
      JSON.stringify({
        success: true,
        message: "Folder and associated flashcards deleted successfully",
        data: {
          folderId: folderId,
          deletedAt: new Date().toISOString(),
        },
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-cache", // Prevent caching
        },
      }
    );

  } catch (error) {
    console.error("Error in DELETE /api/folders/[folderId]:", error);

    // Handle specific error types
    if (error instanceof Error) {
      // Folder not found or access denied
      if (error.message.includes("Folder not found") || 
          error.message.includes("Access denied")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Folder not found",
            message: error.message,
          }),
          {
            status: 404,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }

      // Validation errors
      if (error.message.includes("Invalid") || 
          error.message.includes("Failed to verify")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Validation error",
            message: error.message,
          }),
          {
            status: 400,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }

      // Database connection errors
      if (error.message.includes("Failed to delete") || 
          error.message.includes("Database error")) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Database error",
            message: "Failed to delete folder from database",
          }),
          {
            status: 500,
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
      }
    }

    // Generic server error for unhandled cases
    return new Response(
      JSON.stringify({
        success: false,
        error: "Internal server error",
        message: "An unexpected error occurred while processing the request",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
};


================================================
FILE: src/pages/folders/[folderId].astro
================================================
---
import AuthLayout from '../../layouts/AuthLayout.astro';
import FolderView from '../../components/views/FolderView';

export const prerender = false;

const { folderId } = Astro.params;

if (!folderId) {
  return Astro.redirect('/dashboard');
}

// Sprawdź czy użytkownik jest zalogowany (middleware powinien przekierować, ale double-check)
const { user } = Astro.locals;

if (!user) {
  return Astro.redirect('/login');
}
---

<AuthLayout title="Folder Details">
  <FolderView folderId={folderId} userId={user.id} client:load />
</AuthLayout>


================================================
FILE: src/pages/study/[folderId].astro
================================================
---
import AuthLayout from '@/layouts/AuthLayout.astro';
import StudySessionView from '@/components/views/StudySessionView';

export const prerender = false;

const { folderId } = Astro.params;

if (!folderId) {
  return Astro.redirect('/dashboard');
}
---

<AuthLayout title="Sesja Nauki - 10x Cards Flipper">
  <StudySessionView client:load folderId={folderId} />
</AuthLayout>


================================================
FILE: src/styles/global.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


